	TITLE	'XIOS200, Copyright 1980, ALTOS COMPUTER SYSTEMS'
;----------------------------------------------------------
;
;	ALTOS COMPUTER SYSTEMS
;	2360 BERING DRIVE
;	SAN JOSE, CALIFORNIA 95131
;
;	Copyright 1980, ALTOS COMPUTER SYSTEMS
;
;	This program is a copyright program product of
;	ALTOS COMPUTER SYSTEMS and is distributed to the
;	owners of ALTOS SUN SERIES 8000 computers for
;	use on those systems only. Any other use of this
;	software constitutes a breach of the copyright
;	license to the purchaser. However, permission is
;	granted to use this listing as a sample for the
;	construction of the reader's own XIOS.
;
;	VERSION NUMBER: 1.12*
;	VERSION DATE:   June 28, 1980
;	.       Add support for CP/M version   2.0
;	.       Add support for Hard disk drives
;	.       Add support for disk MODE selection
;	.       Provide compatability MODE for 1.4 operatio
;	.       Remove CTC/1791 counter reset
;	.       CORRECT HARD DISK SEEK PROBLEM
;	.       Add code to recover from WD1791 going to sl
;	.       Initialize parallel port for Centronics printer
;	VERSION DATE:   March 17, 1981
;	Virtual disk in banks 1,2,3:  M DISK !;
;	VERSION DATE:   April 11, 1981
;	.       Conditional assembly for virtual disks
;	Conditional assembly for MP/M 2.0
;	VERSION DATE:   April 14, 1981
;	.       Equates added for LDRBIOS hooks  !
;	VERSION DATE:   April 16, 1981
;	.       Testing for bank setup added
;
;
;	Mode	0	IBM single density
;		1	ALTOS double density Version 2.0
;		2	ALTOS double density Version 1.4
;		3	ALTOS hard disk Version 2.0 (8 MEG AT 000)
;		4	ALTOS HARD DISK VERSION 2.0 (8 MEG AT 512)
;		5	ALTOS HARD DISK VERSION 2.0 (8 MEG AT 1024)
;		6	ALTOS HARD DISK VERSION 2.0 (4 MEG AT 512)
;
;----------------------------------------------------------
	
;----------------------------------------------------------
;
;	ASSEMBLER CONTROL STATEMENTS
;
;----------------------------------------------------------
	include "diskdef.lib"
;	MACLIB	DISKDEF	; Replaced by include statement
;	MACLIB	Z80S	; Not needed, have a Z80 assembler

;; TRUE	EQU	0FFFFH	;VALUE FOR TRUE
;; FALSE	EQU	NOT TRUE	;VALUE FOR FALSE

MDISK	equ	FALSE	;Virtual Disk cond asm bool
MPM20	equ	TRUE	;MP/M 2.0 cond asm boolean

;----------------------------------------------------------
LDRBIOSBASE	equ	1700h	; for M

DENSITY_MASK_OFFSET	equ	37h ;density mask offset from LDRBI
MISC_PARAMS_OFFSET	equ	0bbh ;misc. parameters offset from L

;-----------------------------------------------------------------------
;
;	THE FOLLOWING EQUATES ARE USER MODIFIABLE BASED ON THE
;	PARTICULAR USER SYSTEM AND OPTIONS SELECTED.
;
;-----------------------------------------------------------------------

DMA	EQU	TRUE		;DMA HARDWARE SUPPORT ??
HARDSK	EQU	TRUE		;HARD DISK SUPPORT

;----------------------------------------------------------
;	THE FOLLOWING CONSTANTS APPLY TO THE DEBLOCKING OF
;	SECTORS	LARGER THAN 128 FOR THE ALTOS DOUBLE DENSIT
;	AND THE ALTOS HARD DISK.
;----------------------------------------------------------

BLKSIZ	EQU	16384		;CP/M ALLOCATION SIZE
HSTSIZ	EQU	1024		;HOST DISK SECTOR SIZE
HSTSPT	EQU	16		;HOST DISK SECTORS PER TRAC
HSTBLK	EQU	HSTSIZ/128	;CP/M SECTORS PER HOST BUFF
CPMSPT	EQU	HSTBLK * HSTSPT	;CP/M SECTORS PER TRACK
SECMSK	EQU	HSTBLK - 1	;SECTOR MASK
SECSHF	EQU	3		;LOG2(HHSTBLK)

;-----------------------------------------------------------------------
;
;	THE FOLLOWING EQUATES APPLY TO THE RELOCATABILITY
;	OF THE CBIOS AND SHOULD NOT BE USER ALTERED.
;
;-----------------------------------------------------------------------

RELOC	EQU	TRUE		;RELOCATABLE VERSION ??

;----------------------------------------------------------

	if	MDISK
MAXDSK	equ	13
	else
	IF	HARDSK
MAXDSK	EQU	12		;MAXIMUM NUMBER OF LOGICAL
	ELSE
MAXDSK	EQU	4		;MAXIMUM NUMBER OF LOGICAL
	ENDIF
	endif

	IF	RELOC
	ORG	0000H
	ELSE
	ORG	0C000H
	ENDIF

BASE	EQU	$

;----------------------------------------------------------

WRALL	EQU	0		;WRITE TO ALLOCATED
WRDIR	EQU	1		;WRITE TO DIRECTORY
WRUAL	EQU	2		;WRITE TO UNALLOCATED

NMBCNS	EQU	4	; NUMBER OF CONSOLES

POLL	EQU	131	; XDOS POLL FUNCTION
FLAGWT	EQU	132	; XDOS FLAG WAIT FUNCTION
FLAGST	EQU	133	; XDOS FLAG SET FUNCTION

HDFLAG	EQU	5	;HARD DISK FLAG FOR WAIT & SET
FPYFLAG	EQU	6	;FLOPPY DISK FLAG FOR WAIT & SET

PLLPT	EQU	0	; POLL PRINTER
PLCO0	EQU	PLLPT+1	; POLL CONSOLE OUT #0 (CRT:)
PLCO1	EQU	PLCO0+1	; POLL CONSOLE OUT #1 (CRT:)
PLCO2	EQU	PLCO1+1	; POLL CONSOLE OUT #2 (CRT:)
PLCO3	EQU	PLCO2+1	; POLL CONSOLE OUT #3 (CRT:)
PLCI0	EQU	PLCO3+1	; POLL CONSOLE IN #0 (CRT:)
PLCI1	EQU	PLCI0+1	; POLL CONSOLE IN #1 (CRT:)
PLCI2	EQU	PLCI1+1	; POLL CONSOLE IN #2 (CRT:)
PLCI3	EQU	PLCI2+1	; POLL CONSOLE IN #3 (CRT:)

MEMPORT	EQU	009H	; MEMORY SELECT PORT
MEMSK	EQU	002H	; MEMORY SELECT MASK

;-----------------------------------------------------------------------
;
;	JUMP VECTORS FOR ENTRIES TO CBIOS ROUTINES
;
;-----------------------------------------------------------------------

;	EXTERNAL JUMP TABLE (BELOW XIOS BASE)

;PDISP	EQU	 $-3
;XDOS	EQU	 PDISP-3

	if	MPM20
	jp	COMMONBASE
	else
	JP	COLDSTART	;COLD START
	endif
WBOTE:
	JP	WARMSTART	;WARM START
	JP	CONST		;CONSOLE STATUS
	JP	CONIN		;CONSOLE CHARACTER IN
	JP	CONOUT		;CONSOLE CHARACTER OUT
	JP	LIST		;LIST CHARACTER OUT - THIS
;				;  "CLIST" IF SETUP PROGRAM
;				;  PARALLEL PRINTER PORT

	JP	RTNEMPTY	;PUNCH NOT IMPLEMENTED
	JP	RTNEMPTY	;READER NOT IMPLEMENTED
	JP	HOMEIT		;MOVE HEAD TO HOME
	JP	SELDSK		;SELECT DISK
	JP	SETTRK		;SET TRACK NUMBER
	JP	SETSEC		;SET SECTOR NUMBER
	JP	SETDMA		;SET DMA ADDRESS
	JP	READ		;READ DISK
	JP	WRITE		;WRITE DISK
	JP	POLLPT		;LIST STATUS
	JP	SECTRAN		;SECTOR TRANSLATE

;	EXTENDED I/O SYSTEM JUMP VECTOR

	JP	SELMEMORY	; SELECT MEMORY
	JP	POLLDEVICE	; POLL DEVICE
	JP	STARTCLOCK	; START CLOCK
	JP	STOPCLOCK	; STOP CLOCK
	JP	EXITREGION	; EXIT REGION
	JP	MAXCONSOLE	; MAXIMUM CONSOLE NUMBER

	JP	SYSTEMINIT	; SYSTEM INITIALIZATION
	NOP			; NO JMP HERE
	NOP			; FOR MP/M DELAY
	NOP			;

	JP	SETMOD		;ROUTINE TO SET DISK MODE
	JP	RETMOD		;ROUTINE TO RETURN CURRENT

	if	~~MPM20
COLDSTART:
WARMSTART:
	LD	C,0		; SEE SYSTEM INIT
				; COLD & WARM START INCLUDE
				; FOR COMPATIBILITY WITH CP
	JP	XDOS		; SYSTEM RESET, TERMINATE P

RTNEMPTY:
	XOR	A		; NOT USED
	RET			;
	endif

LAST:
	ORG	(((LAST-BASE)+0A2H) & 0FF00H) +05EH

INTERUPT:
	DW	FLOPPY_INT	;FLOPPY DISK INTERR
	DW	NULL_INT	;
	DW	NULL_INT	;
	DW	NULL_INT	;
	DW	INT1HND		;CTC INTERRUPT
	DW	NULL_INT	;
	DW	HARD_INT	;HARD DISK INTERRUP
	DW	NULL_INT	;
	DW	NULL_INT	;

	if	~~MPM20
NULL_INT:
	EI
	RETI
	endif

;-----------------------------------------------------------------------
;
;	WORK AND CONTROL AREAS FOR CBIOS SERVICES
;
;-----------------------------------------------------------------------

TRK0:	DB	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH
SEL0:	DB	004H,008H,010H,020H,010H,010H,010H,020H,020H,020H,010H,020H
MODE:	DB	000H,000H,000H,000H,003H,004H,005H,003H,004H,005H,006H,006H
TCNT:	DB	000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
PCNT:	DB	000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H    

DISKNO:	DB	000H				;CURRENT DRIVE NUMBER
TRAKNO:	DB	000H				;CURRENT TRACK NUMBER
HEADNO:	DB	000H				;CURRENT HEAD NUMBER
DMAADR:	DW	000H				;CURRENT DMA ADDRESS
SECTNO:	DB	000H				;CURRENT SECTOR NUMBER
DPEPTR:	DW	000H				;CURRENT DPE ADDRESS
DBLKAD:	DW	000H				;CURRENT EXTENSION ADDRESS
MPARMS:	DW	000H				;MISC. PARAMETERS
HTK1:	DB	10H				;HARD DISK  # 1  TRACK
HTK2:	DB	20H				;HARD DISK  # 2  TRACK
;
;	PARAMETER FLAGS
;
;	0100H = DOUBLE HEADED DRIVES
;	0200H = CENTRONICS PRINTER FOR LIST DEVICE
;	0400H = FOUR DRIVE SYSTEM  [ A B C D ]
;-----------------------------------------------------------------------
;
;-----------------------------------------------------------------------
;
;	NOTE:
;	NO CHANGES ARE TO BE MADE TO THE ABSOLUTE LOCATIONS OF
;	ANY FIELDS PRIOR TO THIS POINT. EXTERNAL PROGRAMS ARE
;	DEPENDENT UPON THE LOCATION OF THE PRECEEDING DATA.
;
;-----------------------------------------------------------------------


	IF	~~DMA
NMIRTN:	DB	0EDH,0A2H,0EDH,045H		;FAKE INI AND RETN INST
	ENDIF

DMAS1:	DB	0C3H,07DH			;FIRST PART OF DMA SETUP
DMASA:	DW	000H				;ADDRESS FOR I/O
DMALEN:	DW	1025-1				;LENGTH FOR I/O

DMAS2H:	DB	054H,0CEH,068H,0CEH,0A5H,020H	;HARD DISK SETUP

DMAS2F:	DB	014H,028H,085H,007H		;FLOPPY DISK SETUP

DMAS3:	DB	08AH,0CFH,001H,0CFH		;LAST PART OF DMA SETUP
DMAS3F:	DB	001H				;001=READ, 005=WRITE
	DB	0CFH,087H			;SETUP DMA, ENABLE

;-----------------------------------------------------------------------
;
;	CONTROL BLOCKS FOR DISK DRIVER
;
;-----------------------------------------------------------------------

DPBASE	EQU	$		;START OF DISK PARAMETER BLOCKS

DPE0:	DW	XLT0,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB0	;DIR BUFF, PARM BLOCK
	DW	CSV0,ALV0	;CHECK VECTOR, ALLOC VECTOR

DPE1:	DW	XLT0,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB0	;DIR BUFF, PARM BLOCK
	DW	CSV1,ALV1	;CHECK VECTOR, ALLOC VECTOR

DPE2:	DW	XLT0,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB0	;DIR BUFF, PARM BLOCK
	DW	CSV2,ALV2	;CHECK VECTOR, ALLOC VECTOR

DPE3:	DW	XLT0,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB0	;DIR BUFF, PARM BLOCK
	DW	CSV3,ALV3	;CHECK VECTOR, ALLOC VECTOR

	IF	HARDSK

DPE4:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB3	;DIR BUFF, PARM BLOCK
	DW	CSV4,ALV4	;CHECK VECTOR, ALLOC VECTOR

DPE5:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB4	;DIR BUFF, PARM BLOCK
	DW	CSV5,ALV5	;CHECK VECTOR, ALLOC VECTOR

DPE6:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB5	;DIR BUFF, PARM BLOCK
	DW	CSV6,ALV6	;CHECK VECTOR, ALLOC VECTOR

DPE7:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB3	;DIR BUFF, PARM BLOCK
	DW	CSV7,ALV7	;CHECK VECTOR, ALLOC VECTOR

DPE8:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB4	;DIR BUFF, PARM BLOCK
	DW	CSV8,ALV8	;CHECK VECTOR, ALLOC VECTOR

DPE9:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB5	;DIR BUFF, PARM BLOCK
	DW	CSV9,ALV9	;CHECK VECTOR, ALLOC VECTOR

DPEA:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB6	;DIR BUFF, PARM BLOCK
	DW	CSVA,ALVA	;CHECK VECTOR, ALLOC VECTOR

DPEB:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB6	;DIR BUFF, PARM BLOCK
	DW	CSVB,ALVB	;CHECK VECTOR, ALLOC VECTOR

	ENDIF

	if	MDISK
;		Virtual	disk parameter header

DPEC:	DW	0000H,0000H	;TRANSLATE TABLE AND WORK AREA
	DW	0000H,0000H	;SCRATCH AREA
	DW	DIRBUF,DPB7	;DIR BUFF, PARM BLOCK
	DW	CSVC,ALVC	;CHECK VECTOR, ALLOC VECTOR
	endif

;----------------------------------------------------------

MODL0:	DW	XLT0,000H	;MODEL DPE FOR MODE 0
	DW	000H,000H
	DW	DIRBUF,DPB0

MODL1:	DW	XLT1,0000H	;MODEL DPE FOR MODE 1
	DW	0000H,0000H
	DW	DIRBUF,DPB1

MODL2:	DW	XLT2 ,0000H	;MODEL DPE FOR MODE 2
	DW	0000H,0000H
	DW	DIRBUF,DPB2

;----------------------------------------------------------

XLT0:	DB	1,7,13,19,25,5,11,17,23,3,9,15,21
	DB	2,8,14,20,26,6,12,18,24,4,10,16,22

XLT1:
XLT2:
	DB	 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13
	DB	14,15,16,17,18,19,20,21,22,23,24,25,26
	DB	27,28,29,30,31,32,33,34,35,36,37,38,39
	DB	40,41,42,43,44,45,46,47,48,49,50,51,52

;----------------------------------------------------------
;
;	DISK ACCESS ROUTINES
;
;----------------------------------------------------------

SELDSK:
	LD	A,C		;LIMIT SELECT TO REAL OPTIO
	CP	MAXDSK		;
	JR	NC,SELERR	;  INVALID DRIVE
	LD	A,E		; TEST FOR INITIAL SELECT
	AND	1		;   E = 0  IS FIRST TIME
	PUSH	AF		;
	LD	D,0		;
	LD	E,C		; TRANSLATE TABLE
	LD	HL,DTBLT	;  FOR LOGICAL TO PHYSICAL
	ADD	HL,DE		;
	LD	C,(HL)		;  C = PHYSICAL DRIVE
	LD	A,C		; M translates to the 12 di

	if	MDISK
	CP	12
	JP	Z,VIRTUAL
	endif

;	POP	AF		; RESTORE TEST
;	JR	NZ,SELSDP	; BYPASS SELECT
SETDSK:
	LD	B,0		;
	LD	HL,SEL0		; BASE OF SELECT MASKS
	ADD	HL,BC		;
	LD	A,(HL)		;  GET SELECT BYTE
	AND	A		;   CHECK FOR VALID DRIVE
	JR	Z,SELERR	;    DRIVE NOT CONFIGURED
	LD	A,C		;
	CP	4		; CHECK FOR FLOPPY
	JR	C,SELSDP	;
CHKHRD:	LD	A,(HL)		; RESTORE SELECT BYTE
	OUT	(20H),A		;
	PUSH	BC		;
	LD	C,1		; DELAY FOR 1 MS
	CALL	DELAY		;
	POP	BC		;
	IN	A,(24H)		; CHECK FOR HARD DISK READY
	RLA			; 80H = READY
	JR	NC,SELERR	;
SELSDP:
	LD	A,C		;

	if	MDISK
VIRTUAL:
	endif

	LD	(NEWDSK),A		;SAVE FOR I/O LATER
	LD	H,0		;

	LD	L,C		;COMPUTE DP HEADER ADDRESS
	ADD	HL,HL		;* 2
	ADD	HL,HL		;* 4
	ADD	HL,HL		;* 8
	ADD	HL,HL		;* 16 (DP HEADER SIZE)
	LD	DE,DPBASE	;START OF DP HEADERS
	ADD	HL,DE		;POINT TO CORRECT ONE
	LD	(DPEPTR),HL		;SAVE ADDRESS OF CURRENT DP
	RET			;

SELERR:	LD	HL,0		; INDICATE ERROR
	RET			; AND RETURN

;		A,B,C,D,E,F,G,H,I,J, K, L,M ,N,O
DTBLT:	DB	0,1,2,3,4,5,6,7,8,9,10,11,12,0,0

SETDMA:
	LD	H,B		;TO ALLOW SAVING
	LD	L,C		;
	LD	(DMAADR),HL		;

	if	MPM20
	inc	hl		;test for flush buffers
	ld	a,1
	or	h
	ret	nz		;HL = FFFFh is flush buffer
	ld	hl,HSTWRT
	ld	a,(hl)
	ld	(hl),0
	or	a
	ret	z
	call	WRITEHST	;flush host write if pendin
	or	a
	ret	z		;return if no error
	pop	hl
	endif

	ret

SETTRK:
	LD	H,B		;TO ALLOW SAVE
	LD	L,C		;
	LD	(NEWTRK),HL		;SAVE NEXT TRACK NUMBER
	RET			;RETURN TO CALLER

SETSEC:
	LD	A,C		;FOR SAVE
	LD	(NEWSEC),A		;
	RET			;RETURN TO CALLER

SETDEN:
	LD	DE,SEL0		;START OF SELECT/DENSITY MA
	LD	HL,(NEWDSK)		;NEXT DRIVE ADDRESS
	LD	H,000H		;ENSURE ZERO FOR SINGLE BYT
	ADD	HL,DE		;POINT TO CORRECT MASK
	LD	A,C		;ISOLATE DENSITY BIT
	AND	00000001B	;
	LD	C,A		;SAVE FOR NOW
	LD	A,(HL)		;LOAD SELECT DENSITY MASK
	AND	11111110B	;RESET CURRENT DENSITY SETT
	OR	C		;SET NEW VALUE
	LD	(HL),A		;RESTORE MASK IN TABLE
	RET			;RETURN TO CALLER

	if	MDISK
MREADSECTOR:
	call	compbank	;compute bank
	di
	call	chgbank
	ld	bc,128
	ld	de,localbuf
	ld	hl,(addroff)
	ldir			;blockmove into the dma ar
	ld	a,02h		; select bank 0
	out	(09h),a
	ei
	ld	bc,128
	ld	hl,(dmaadr)
	ex	de,hl
	ld	hl,localbuf
	ldir
	xor	a
	ret

MBANKNO		db	0
ADDROFF		dw	0
LOCALBUF	ds	128

COMPBANK :
	ld	a,(newtrk)
	ld	h,a
	and	0fh	;save track rem 16
	ld	l,a
	ld	a,h	;restore track
	ld	h,0
	and	0f0h		; bank is high order nibble
	rar ! rar ! rar ! rar
	inc	a
	ld	(mbankno),a		; which bank we want

	add	hl,hl		;trk 0-15
	add	hl,hl		; * 2
	add	hl,hl		; * 4
	ld	e,1
	ld	d,h
	add	hl,de
	add	hl,de		; * 24:

	ld	a,(newsec)		; figure offset within the
	ld	e,a
	ld	d,0
	add	hl,de		; add sector offset within
	add	hl,hl ! dad h ! dad h ! dad h ! dad h ! dad h !
	ld	(addroff),hl		; (track * 24 + sector) * 1
	ret
	endif

READ:
	if	MDISK
	LD	A,(NEWDSK)
	CP	12		;VIRTUAL DISK ?
	JP	Z,MREADSECTOR
	endif

	CALL	RETMOD		;WHAT TYPE OF I/O ??
	CP	003H		;
	JP	C,READSOFT	;FLOPPY DISK DRIVE....
	JP	READHARD	;HARD DISK I/O

	if	MDISK
MWRITESECTOR:
	call	compbank
	lhid	dmaadr
	ld	de,localbuf
	ld	bc,128
	ldir
	di
	call	chgbank
	ld	de,localbuf
	ld	bc,128
	lhid	addroff
	ex	de,hl
	ldir
	ld	a,02h		; select bank 0
	out	(09h),a
	ei
	xor	a
	ret

CHGBANK:
	ld	a,(mbankno)
	ral
	ral
	ral
	and	018h
	or	memsk
	out	(009h),a
	ret
	endif

WRITE:
	if	MDISK
	ld	a,(newdsk)
	cp	12
	jp	z,mwritesector
	endif

	CALL	RETMOD		;WHAT TYPE OF I/O ??
	CP	003H		;
	JP	C,WRITESOFT	;FLOPPY DISK
	JP	WRITEHARD	;HARD DISK I/O

;----------------------------------------------------------
;
;	ROUTINES TO SET AND RETURN THE CURRENT DRIVE MODE
;
;----------------------------------------------------------

SETMOD:
	LD	HL,NEWDSK	; SAVE NEWDSK IN STACK
	LD	A,(HL)		;
	PUSH	AF		;
	LD	(HL),B		;
	PUSH	BC		;
	LD	E,0		; INDICATE INITIAL SELECT
	LD	C,B		; CALL DISK SELECT
	CALL	SELDSK		;
	POP	BC		;
	LD	A,H		; CHECK FOR BAD SELECT
	OR	L		;
	JR	Z,SMERR		;   YES - ABORT CHANGING
	LD	L,B		;  B AND L = DRIVE #
	LD	H,000H		;
	LD	A,B		;CHECK MODE SET VALIDITY
	CP	004H		;ONLY VALID FOR FLOPPY DISK
	JR	NC,SMERR	;INVALID DRIVE FOR MODE SET
	LD	DE,MODE		;START OF MODE BYTES
	ADD	HL,DE		;
	LD	(HL),C		;SAVE NEW MODE BYTE
	PUSH	HL		;SAVE MODE BYTE ADDRESS
	LD	A,C		;SETUP FOR DENSITY CHANGE
	OR	A		;
	LD	C,000H		;ASSUME SINGLE DENSITY MODE
	JR	Z,SETSEL		;VERIFY ASSUMPTION
	LD	C,001H		;SET FOR DOUBLE DENSITY MOD
SETSEL:	CALL	SETDEN		;SET DENSITY BASED ON LOW B
	POP	HL		;RESTORE
	LD	L,(HL)		;PICKUP MODE AGAIN
	LD	H,000H		;FOR SINGLE BYTE PRECISION
	LD	A,L		;SAVE MODE IN ACCUMULATOR F
	ADD	HL,HL		;* 2
	ADD	HL,HL		;* 4
	PUSH	HL		;SAVE * 4
	ADD	HL,HL		;* 8
	POP	DE		;REGAIN * 4
	ADD	HL,DE		;* 12
	LD	DE,MODL0		;FIRST MODEL DPE
	ADD	HL,DE		;POINT TO THIS ONE
	EX	DE,HL		;SETUP TEMPORARILY AS DESTI
	LD	HL,(DPEPTR)		;ADDRESS OF CURRENTLY SELEC
	EX	DE,HL		;SETUP TO ALTER
	LD	BC,12		;LENGTH FOR MOVE
	LDIR			;DO MOVE
SMERR:	POP	AF		;
	PUSH	HL		;
	LD	(NEWDSK),A	; RESTORE ORIGINAL NEWDSK
	LD	C,A		;
	CALL	SELDSK		;
	POP	HL		;
	RET			;RETURN TO CALLER

RETMOD:
	LD	DE,MODE		;START OF MODE BYTES
	LD	HL,(NEWDSK)	;NEXT DRIVE FOR I/O
	LD	H,000H		;RESET FOR SINGLE BYTE QUAN
	ADD	HL,DE		;POINT TO IT....
	LD	A,(HL)		;LOAD IT FOR CALLER
	RET			;RETURN, WITH CURRENT MODE

;----------------------------------------------------------
;
;	THIS IS THE HOME DEVICE ROUTINE
;
;----------------------------------------------------------

HOMEIT:	LD	A,(NEWDSK)	; CHECK FOR FIRST HOME
	CP	12		; CHECK FOR VIRTUAL DISK
	JP	NZ,REALDISK
	XOR	A		; VIRTUAL DISK
	LD	H,A		; SET TRACK TO ZERO
	LD	L,A
	LD	(NEWTRK),HL
	RET
REALDISK:
	CP	4		;  CHECK FOR FLOPPY
	JR	C,HOME		;  DO NOT BYPASS FLOPPY HOM
	LD	C,A		;
	LD	B,0		; POINT TO PRESENT TRACK ST
	LD	HL,TRK0		;
	ADD	HL,BC		;
	LD	A,(HL)		; CHECK IF INITIALIZED
	CP	0FFH		;
	LD	A,0		;
	RET	NZ		; YES - RETURN WITH NO ER
	LD	(HL),A		;
HOME:
	LD	A,(NEWDSK)	;GET VALUE OF DRIVE FOR HOM
	CP	004H		;IS IT A HARD DISK ??
	JR	NC,HOMEHARD	;YES, PROCESS....

HOMESOFT:
	CALL	DSKSEL		;SELECT CORRECT DRIVE (IN A
	LD	A,(ERFLAG)	;
	OR	A		;CHECK FOR ERRORS DURING SE
	JR	NZ,HOME1A	;EXIT IF ERRORS
	CALL	POINT		;POINT TO TRACK REGISTER SA
	LD	(HL),000H	;RESET TO TRACK ZERO
	CALL	DBL_UPDATE	;
	LD	A,00AH		;HOME COMMAND....
	CALL	FINTFIX		;CLEAR ANY PENDING INTERRUP
				;AND ISSUE COMMAND
HOME1:	CALL	FPYWAIT		;WAIT UNTIL I/O COMPLETE
	LD	A,(STATUS)	;PICKUP STATUS BYTE
	AND	10011000B	;CHECK STATUS
	RET	Z		;RETURN WITH GOOD ESULT
HOME1A:	LD	A,001H		;SET ERROR ON HOME
	RET			;AND RETURN....

HOMEHARD:
	IF	HARDSK
	CALL	DSKSEL		;SELECT CORRECT DRIVE (IN A
	CALL	POINT		;POINT TO SAVE AREA
	LD	(HL),000H	;SET TO TRACK ZERO
	EX	DE,HL		;POINT TO SELECT WORD
	LD	A,(HL)		;LOAD SELECT MASK
	AND	11110000B	;RESET HEAD MASK
	LD	(HL),A		;SAVE
	OUT	(020H),A	;WRITE HEAD/SELECT MASK
	LD	A,020H		;HOME COMMAND
	CALL	INTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND
HOME2:	CALL	WAIT0		;WAIT UNTIL I/O COMPLETE
	LD	C,20		;DELAY FOR 20 MILLISECONDS
	CALL	DELAY		;
	XOR	A		;SET NEW TRACK REGISTER TO
	OUT	(022H),A	;FOR CONTROLLER
;	LD	HL,MHM		;*** DEBUG **
;	CALL	MSPRT		;***DEBUG* **
	LD	A,(STATUS)	;PICKUP STATUS BYTE
	AND	01011101B	;CHECK STATUS
	RET	Z		;
	LD	A,001H		;SET ERROR ON HOME
	ENDIF
	RET			;AND RETURN

;----------------------------------------------------------
;
;	THESE ARE THE HARD DISK UNBLOCK/REBLOCK AND READ AN
;	ROUTINES CALLED BY THE BDOS SOFTWARE.
;
;----------------------------------------------------------

READHARD:
	IF	HARDSK
	XOR	A		;RESET UNALLOCATED COUNT
	LD	(UNACNT),A	;
	LD	A,001H		;READ THE SELECTED CP/M SEC
	LD	(READOP),A	;
	LD	(RSFLAG),A	;MUST READ DATA
	LD	A,WRUAL		;
	LD	(WRTYPE),A	;TREAT AS UNALLOCATED
	JR	RWOPER		;TO PERFORM THE READ.
	ENDIF

WRITEHARD:
	IF	HARDSK
	XOR	A		;WRITE THE SELECTED CP/M SE
	LD	(READOP),A	;NOT A READ OPERATION
	LD	A,C		;WRITE TYPE IS PASSED IN RE
	LD	(WRTYPE),A	;

	if	MPM20
	and	WRUAL		;IS IT WRITE UNALLOCATED ??
	JR	Z,CHKUNA	;CHECK FOR UNALLOCATED
	else
	CP	WRUAL		;IS IT WRITE UNALLOCATED ??
	JR	NZ,CHKUNA	;CHECK FOR UNALLOCATED
	endif
;
;	WRITE TO UNALLOCATED, SET PARAMETERS
;

	LD	A,BLKSIZ/128	;NEXT UNALLOC RECS
	LD	(UNACNT),A	;
	LD	A,(NEWDSK)	;DISK FOR I/0
	LD	(UNADSK),A	;UNADSK = NEWDSK
	LD	HL,(NEWTRK)	;
	LD	(UNATRK),HL	;UNATRK = NEWTRK
	LD	A,(NEWSEC)	;
	LD	(UNASEC),A	;UNASEC = NEWSEC
;
;	CHECK FOR WRITE TO UNALLOCATED SECTOR
;

CHKUNA:
	LD	A,(UNACNT)	;ANY UNALLOCATED REMAIN ??
	OR	A		;
	JR	Z,ALLOC		;SKIP IS NOT

;
;	MORE UNALLOCATED RECORDS REMAIN
;

	DEC	A		;UNACNT = UNACNT - 1
	LD	(UNACNT),A	;
	LD	A,(NEWDSK)	;SAME DISK ??
	LD	HL,UNADSK	;
	CP	(HL)		;NEWDSK = UNADSK ??
	JR	NZ,ALLOC	;SKIP IF NOT

;
;	DISKS ARE THE SAME
;

	LD	HL, UNATRK	;
	CALL	NEWTRKCMP	;NEWTRK = UNATRK ??
	JR	NZ,ALLOC	;SKIP IF NOT

;
;	TRACKS ARE THE SAME
;

	LD	A,(NEWSEC)	;SAME SECTOR ??
	LD	HL,UNASEC	;
	CP	(HL)		;NEWSEC = UNASEC ??
	JR	NZ,ALLOC	;SKIP IF NOT

;
;	MATCH, MOVE TO NEXT SECTOR FOR FUTURE REFERENCE
;

	INC	(HL)		;UNASEC = UNASEC + 1
	LD	A,(HL)		;END OF TRACK ??
	CP	CPMSPT		;COUNT CP/M SECTORS
	JR	C,NOOVF		;SKIP IF NO OVERFLOW

;
;	OVERFLOW TO NEXT TRACK
;

	LD	(HL),000H	;UNASEC = 0
	LD	HL,(UNATRK)	;
	INC	HL		;
	LD	(UNATRK),HL	;UNATRK = UNATRK + 1

;
;	MATCH	FOUND, MARK AS UNNECESSARY READ
;

NOOVF:
	XOR	A		;ZERO TO ACCUMULATOR
	LD	(RSFLAG),A	;RSFLAG = 0
	JR	RWOPER		;TO PERFORM THE WRITE

;
;	NOT	AN UNALLOCATED RECORD, REQUIRES PRE-READ
;

ALLOC:
	XOR	A		;ZERO TO ACCUMULATOR
	LD	(UNACNT),A	;UNACNT = 0
	INC	A		;ONE TO ACCUMULATOR
	LD	(RSFLAG),A	;RSFLAG = 1

;----------------------------------------------------------
;
;	THE FOLLOWING CODE IS COMMON TO BOTH READ AND WRITE
;
;----------------------------------------------------------

RWOPER:
	XOR	A		;ZERO TO ACCUMULATOR
	LD	(ERFLAG),A	;NO ERRORS YET....
	LD	A,(NEWSEC)	;COMPUTE HOST SECTOR
	REPT	SECSHF		;COMPUTE HOST SECTOR
	OR	A		;CARRY = 0
	RRA			;SHIFT RIGHT
	ENDM
	LD	(NEWHST),A	;HOST SECTOR TO SEEK

;
;	ACTIVE HOST SECTOR ??
;

	LD	HL,HSTACT	;HOST ACTIVE FLAG
	LD	A,(HL)		;
	LD	(HL),001H		;ALWAYS BECOMES 1
	OR	A		;WAS IT ALREADY ??
	JR	Z,FILLHST		;FILL HOST IF NOT

;
;	HOST BUFFER ACTIVE, SAME AS SEEK BUFFER
;

	LD	A,(NEWDSK)		;
	LD	HL,HSTDSK	;SAME DISK ??
	CP	(HL)		;NEWDSK = HSTDSK ??
	JR	NZ,NOMATCH		;

;
;	SAME DISK, SAME TRACK ??
;

	LD	HL,HSTTRK	;
	CALL	NEWTRKCMP	;NEWTRK = HSTTRK ??
	JR	NZ,NOMATCH		;

;
;	SAME DISK, SAME TRACK, SAME BUFFER ??
;

	LD	A,(NEWHST)		;
	LD	HL,HSTSEC	;NEWHST = HSTSEC ??
	CP	(HL)		;
	JR	Z,MATCH		;SKIP IF MATCH

;
;	PROPER DISK, BUT NOT CORRECT SECTOR
;

NOMATCH:
	LD	A,(HSTWRT)		;HOST WRITTEN ??
	OR	A		;
	CALL	NZ,WRITEHST	;CLEAR HOST BUFFER

;
;	MAY HAVE TO FILL HOST BUFFER
;

FILLHST:
	LD	A,(NEWDSK)		;
	LD	(HSTDSK),A		;
	LD	HL,(NEWTRK)		;
	LD	(HSTTRK),HL		;
	LD	A,(NEWHST)		;
	LD	(HSTSEC),A		;
	LD	A,(RSFLAG)		;NEED TO READ ??
	OR	A		;
	CALL	NZ,READHST		;YES, IF 1
	XOR	A		;ZERO TO ACCUMULATOR
	LD	(HSTWRT),A		;NO PENDING WRITE

MATCH:
	LD	A,(NEWSEC)		;MASK BUFFER NUMBER
	AND	SECMSK		;LEAST SIGNIF BITS
	LD	L,A		;READY TO SHIFT
	LD	H,000H		;DOUBLE COUNT
	REPT	7
	ADD	HL,HL		;
	ENDM

;
;	HL NOW HAS RELATIVE HOST BUFFER ADDRESS
;

	LD	DE,HSTBUF	;
	ADD	HL,DE		;HL = HOST ADDRESS
	EX	DE,HL		;NOW IN DE
	LD	HL,(DMAADR)		;GET/PUT CP/M DATA
	EX	DE,HL		;SET FOR Z80 LDIR INSTRUCTION
;	LD	BC,128		;LENGTH OF MOVE
	LD	A,(READOP)		;WHICH WAY ??
	OR	A		;
	JP	NZ,RWMOVE		;SKIP IF READ
;
;	WRITE OPERATION, MARK AND SWITCH DIRECTION
;

	LD	A,001H		;
	LD	(HSTWRT),A		;HSTWRT = 1
	EX	DE,HL		;SWAP DIRECTION
	jp	RWMOVE
	endif

;-----------------------------------------------------------------------
;
;	UTILITY SUBROUTINE FOR 16 BIT COMPARE
;
;-----------------------------------------------------------------------

	IF	HARDSK
NEWTRKCMP:
	EX	DE,HL		;HL = .UNATRK OR .HSTTRK
	LD	HL,NEWTRK	;
	LD	A,(DE)		;LOW BYTE COMPARE
	CP	(HL)		;SAME ??
	RET	NZ		;RETURN IF NOT
	INC	DE		;TO CHECK HIGH BYTE
	INC	HL		;
	LD	A,(DE)		;
	CP	(HL)		;SETS FLAGS
	RET			;

;-----------------------------------------------------------------------
;
;	WRITEHST PERFORMS THE PHYSICAL WRITE TO THE HOST DISK.
;	READHST PERFORMS THE PHYSICAL READ FROM THE HOST DISK.
;
;	HSTDSK = HOST DISK NUMBER
;	HSTTRK = HOST TRACK NUMBER
;	HSTSEC = HOST SECTOR NUMBER
;	RETURN ERROR FLAG IN ERFLAG
;
;-----------------------------------------------------------------------

WRITEHST:
	LD	A,005H		;SETUP DMA FOR WRITE
	LD	(DMAS3F),A		;
	LD	A,002H		;WRITE COMMAND
	LD	(CMD),A		;SAVE FOR LATER
	LD	HL,HSTBUF-1	;WRITE MUST WRITE CONTROL BYTE
	LD	(DMASA),HL		;
	JR	HRW0		;

READHST:
	LD	A,001H		;SETUP DMA FOR READ
	LD	(DMAS3F),A		;
	LD	A,004H		;READ COMMAND
	LD	(CMD),A		;SAVE FOR LATER
	LD	HL,HSTBUF	;READ ONLY DATA BYTES
	LD	(DMASA),HL		;

HRW0:
	LD	A,05		;FIVE RETRIES
	LD	(T_RETRIES),A	;SETUP TEMPORARY RETRIES COUNT
	LD	A,0FFH		;INIT TOGGLE SO THAT NO HOME IS DONE ON FIRST RETRY
	LD	(HOME_TOGGLE),A	;ALTERNATE RETRIES WILL BE DONE WITHOUT HOME
;				;OTHER RETRIES WILL BE DONE WITH HOME

HRW1:
	LD	A,(HSTSEC)		;HOST SETOR NUMBER
	LD	(SECTNO),A		;SAVE SECTOR NUMBER
	LD	A,(HSTDSK)		;PICKUP DRIVE ID FOR SELECT
	CALL	DSKSEL		;SELECT CORRECT DRIVE FOR I/O
	CALL	POINT		;POINT TO TRACK REGISTER SAVE AREA
	EX	DE,HL		;POINT TO SELECT MASK
	LD	A,11110000B	;TO REMOVE CURRENT HEAD SELECTION
	AND	(HL)		;
	LD	(HL),A		;
	PUSH	HL		;SAVE MASK ADDRESS
	CALL	SETHED		;COMPUTE CORRECT HEAD NUMBER
	LD	A,L		;TRACK NUMBER AFTER HEAD CALCULATION
	LD	(TRAKNO),A		;
	POP	HL		;RESTORE MASK ADDRESS
	LD	A,(HEADNO)		;TO OR IN NEW HEAD NUMBER
	OR	(hl)		;
	LD	(HL),A		;SAVE NEW DRIVE/HEAD SELECTION
	AND	07FH		; MASK OFF LARGE DRIVE FLAG
	OUT	(020H),A		;WRITE IT TO SELECT NEW HEAD....
	LD	C,1		;DELAY FOR 1 MILLISECOND
	CALL	DELAY		;

HRW2:
	CALL	POINT		;IS A SEEK NECESSARY ??
	LD	A,(TRAKNO)		;CHECK
	CP	(HL)		;WELL ??
	JR	Z,HRW5		;NO SEEK NECESSARY...

HRW3:
	OUT	(022H),A		;WRITE NEW TRACK NUMBER
	LD	b,(hl)		;SAVE TEMPORARILY
	LD	(HL),A		;UPDATE TRACK REGISTER SAVE AREA
	LD	A,B		;OLD TRACK NUMBER
	OUT	(021H),A		;TO OLD TRACK REGISTER
	LD	A,010H		;SEEK COMMAND
	CALL	INTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND
HRW4:	CALL	WAIT0		;WAIT FOR I/O
	LD	C,20		;DELAY AFTER SEEK FOR 20 MILLISECONDS
	CALL	DELAY		;

HRW5:
	LD	A,(SECTNO)		;SET SECTOR
	OUT	(021H),A		;

HRW6:
	LD	HL,DMAS1		;SETUP DMA FOR HARD DISK I/O
	LD	BC,0600H		;
	OTIR			;
	LD	HL,DMAS2H	;
	LD	BC,0600H		;
	OTIR			;
	LD	HL,DMAS3		;
	LD	BC,0700H		;
	OTIR			;

	LD	A,(CMD)		;PICKUP I/O COMMAND
	CALL	INTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND
HRW7:	CALL	WAIT0		;WAIT FOR COMPLETION

	LD	A,01011101B	;SETUP STATUS AND MASK
	LD	(MASK),A		;SAVE FOR STATUS CHECK
	CALL	CHECK_STAT	;CHECK STATUS FROM I/O
	RET	Z		;OK ??

	LD	A,(HOME_TOGGLE)	;
	CPL			;CHANGE TOGGLE SO THAT HOMES ARE DONE EVERY OTHER RETRY
	LD	(HOME_TOGGLE),A	;

	JP	HRW1		;RETRY I/O
	ENDIF

;-----------------------------------------------------------------------
;
;	DOUBLE SIDED TRACK REGISTER UPDATE ROUTINE
;
;-----------------------------------------------------------------------


DBL_UPDATE:
	LD	A,(MPARMS)		;CHECK FOR DOUBLE SIDED DRIVES
	AND	1		;  IS FLAG SET
	RET	Z		;   NO  - SO RETURN
	LD	A,(DISKNO)		;CURRENT DISK DRIVE
	CP	004H		;IS IT A FLOPPY
	RET	NC		;NO, RETURN WITHOUT UPDATE
	AND	00000010B	;IS THIS DRIVE 2 0R 3 ??
	LD	A,(HL)		;WE WERE CALLED WITH (HL) POINTING TO TRACK
	JR	Z,DBL_LOW		;IT MUST BE DRIVE ZERO OR ONE
	DEC	HL		;BACKUP TO OTHER SIDE POINTER
	DEC	HL		;
	JR	DBL_SAVE	;

DBL_LOW:
	INC	HL		;BUMP UP TO DRIVE TWO OE TRHEE
	INC	HL		;

DBL_SAVE:
	LD	(HL),A		;UPDATE OTHER SIDE REGISTER
	RET			;

;-----------------------------------------------------------------------
;
;	ROUTINE TO COMPUTE HEAD NUMBER FROM TRACK NUMBER
;	TRACK NUMBER IS IN HL ON ENTRY
;
;-----------------------------------------------------------------------
	IF	HARDSK
SETHED:
	LD	HL,(HSTTRK)		;CP/M TRACK NUMBER (0-800)
	AND	80H		; CHECK FOR LARGE DRIVE
	LD	A,L		;LOW ORDER
	JR	Z,SETH14		;  SMALL DRIVE
	AND	00000111B	;GET TRACK MOD 8 (HEAD NUMBER)
	LD	C,3		;LIMIT LOOP FOR DIVIDE BY EIGHT
	JR	SETDVD		;
SETH14:	AND	00000011B	;GET TRACK MOD 4 (HEAD NUMBER)
	LD	C,2		;LIMIT LOOP FOR DIVIDE BY FOUR
SETDVD:	LD	(HEADNO),A		;SAVE AS HEAD NUMBER
SHD1:	OR	A		;ENSURE CARRY IS ZERO
	LD	A,H		;FOR SHIFT
	RRA			;ONE BIT
	LD	H,A		;
	LD	A,L		;LOW ORDER
	RRA			;CARRY PARTICIPATES FROM HIGH ORDER
	LD	L,A		;
	DEC	C		;END OF DIVIDE YET ??
	JR	NZ,SHD1		;NO, CONTINUE
	RET			;RETURN TO CALLER, TRACK IN HL
	ENDIF

;-----------------------------------------------------------------------
;
;	DISK DRIVE SELECT ROUTINE
;		ON ENTRY, THE ACCUMULATOR CONTAINS THE DRIVE FOR SELECTION
;		RETURNS CARRY SET FOR HARD DISK SELECTED
;		RETURNS CARRY RESET FOR FLOPPY DISK SELECTED
;
;-----------------------------------------------------------------------

DSKSEL:
	CP	004H		;IS IT HARD DISK ??
	JR	NC,SELHARD	;YES, GO PROCESS....

SELSOFT:
	LD	HL,DISKNO	;CURRENT DRIVE NUMBER
	CP	(HL)		;SAME DRIVE AS LAST TIME ??
	JR	Z,SLS3		;YES, DONT BOTHER WITH UNLOAD
	LD	(HL),A		;UPDATE WITH CURRENT DRIVE NUMBER

;-----------------------------------------------------------------------
;
;	WE WILL NOW FORCE THE HEAD TO UNLOAD PRIOR TO THE SWITCH
;	TO ENSURE THAT WHEN WE RETURN TO THIS DISK WE WILL
;	LOAD AND WAIT FOR THE HEAD TO SETTLE.
;
;-----------------------------------------------------------------------

SLS1:
	IN	A,(004H)		;ENSURE FLOPPY PORT NOT BUSY
	RRA			;
	JR	C,SLS1		;
	IN	A,(005H)		;READ THE TRACK REGISTER
	OUT	(007H),A		;ENSURE WE DONT MOVE THE HEAD

	LD	A,012H		;SEEK AND UNLOAD HEAD
	CALL	FINTFIX		;CLEAR ANY PENDING INTERRUP
;				;  AND ISSUE COMMAND
SLS2:	CALL	FPYWAIT		;WAIT HERE FOR INTERRUPT
	LD	A,(STATUS)		;HOW DID THE I/O GO?
	AND	10011000B	;  CHECK
	JR	NZ,SLSERR		;EXIT IF ERROR

;-----------------------------------------------------------------------
;
;	WE WILL NOW LOAD THE SELECT MASK AND SELECT THE DRIVE
;	EVEN IF ITS THE SAME DRIVE BECAUSE THE DENSITY MAY
;	HAVE CHANGED.
;
;-----------------------------------------------------------------------

SLS3:
	CALL	POINT		;POINT TO TRACK SAVE AREA
	EX	DE,HL		;POINT TO SELECT MASK
	LD	A,(TRAKNO)		;NEXT TRACK FOR I/O
	CP	002H		;IS IT TRACK ZERO OR ONE
	LD	A,11111111B	;ASSUME NO....
	JR	NC,SLS4		;VERIFY ASSUMPTION
	LD	A,11111110B	;FORCE SINGLE DENSITY FOR 0, & 1

SLS4:
	AND	(HL)		;LOAD MASK AND CORRECT IF NECESSARY
	OUT	(008H),A		;SELECT IT
	IN	A,(004H)		;IS DRIVE READY?
	RLA			;
	JR	C,SLSERR		;IF NOT...BRANCH
	EX	DE,HL		;RESTORE TRACK REGISTER ADD
	LD	A,(HL)		;PICK UP TRACK NUMBER
	OUT	(005H),A		;GIVE IT TO CONTROLLER
	XOR	A		;ENSURE CARRY IS RESET
	LD	(ERFLAG),A		;ALSO ZERO ERROR INDICATOR
	RET

SLSERR:	XOR	A		;ENSURE CARRY IS RESET
	INC	A		;SET TO 1 FOR ERROR FLAG
	LD	(ERFLAG),A		;SHOW ERROR
	RET

;-----------------------------------------------------------------------
;
;	THIS ROUTINE SETS UP THE HARD DISK BY SELECTING THE CORRECT
;	DRIVE AND RELOADING THE HEAD AND TRACK REGISTERS IN THE
;	HARD DISK CONTROLLER READY FOR I/O LATER.
;
;-----------------------------------------------------------------------

SELHARD:
	IF	HARDSK
	LD	HL,DISKNO	;CURRENT DRIVE SELECTED
	CP	(HL)		;SAME ??
	RET	Z		;YES, NO NEW SELECT NECESSARY
	LD	(HL),A		;UPDATE DISKNO

SLH1:
	CALL	POINT		;TRACK SAVE REGISTER
	EX	DE,HL		;POINT TO SELECT MASK
	LD	A,(HL)		;LOAD DRIVE/HEAD VALUE
	OUT	(020H),A		;WRITE IT TO SELECT PORT
	EX	DE,HL		;REGAIN ADDRESS OF TRACK REGISTER
	LD	A,(HL)		;LOAD OLD TRACK NUMBER
	OUT	(022H),A		;WRITE IT TO OLD TRACK REGISTER
	LD	C,20		;DELAY FOR 20 MILLISECONDS AFTER SELECT
	CALL	DELAY		;
	SCF			;SET CARRY TO SHOW HARD DISK
	ENDIF
	RET			;RETURN TO CALLER

;-----------------------------------------------------------------------
;
;	SUBROUTINE TO POINT TO CURRENT TRACK REGISTER SAVE AREA
;
;-----------------------------------------------------------------------

POINT:
	LD	HL,(DISKNO)	   ;PICKUP CURRENT DISK
	LD	A,L	   ;
	LD	H,0	   ;RESET HIGH ORDER HALF
	LD	DE,TRK0	   ;LOAD TRACK POINTER
	ADD	HL,DE	   ;POINT TO CURRENT TRACK PTR
	LD	D,H	   ; DE = TRACK
	LD	E,L	   ;
	LD	BC,12	   ;
	ADD	HL,BC	   ; HL = SELECT
	IF	HARDSK
	CP	4	   ;
	JR	C,PNTFN	   ; FLOPPY DISK
	LD	A,10H	   ;
	AND	(HL)	   ; CHECK DRIVE SELECT
	JR	Z,PNTH2	   ;   MUST BE DRIVE  # 2
	LD	DE,HTK1	   ; POINT TO DRIVE 1
	JR	PNTFN	   ;
PNTH2:	LD	DE,HTK2	   ; POINT TO DRIVE 2
	ENDIF
PNTFN:	EX	DE,HL	   ; SWITCH
	RET		   ; HL = TRACK    DE = SELECT

;----------------------------------------------------------------------
;
;	ROUTINE TO TRANSLATE SECTOR NUMBER
;
;----------------------------------------------------------------------

SECTRAN:
	EX	DE,HL		;TABLE ADDRESS IS IN DE (NOW IN HL)
	LD	A,H		;IS THERE A TABLE ADDRESS ??
	OR	L		;
	JR	Z,STRN2		;NO, JUST ENTERED QU

STRN1:
	LD	B,000H		;ENSURE OK FOR SINGLE BYTE
	ADD	HL,BC		;ADD SECTOR NUMBER
	LD	L,(HL)		;LOAD TRANSLATED VALUE
	LD	H,000H		;
	RET			;NEW VALUE RETURNED IN HL

STRN2:
	ADD	HL,BC		;RETURN SAME VALUE AS ENTER
	RET			;

;-----------------------------------------------------------------------
;
;	ROUTINES TO DO FLOPPY I/O
;
;-----------------------------------------------------------------------

READSOFT:
	LD	A,09FH		;MASK FOR READ STATUS
	LD	(MASK),A	;
	LD	A,001H		;SETUP DMA FOR READ
	LD	(DMAS3F),A	;
	LD	A,08CH		;READ COMMAND
	JR	SRW1		;

WRITESOFT:
	LD	A,0FFH		;MASK FOR WRITE STATUS
	LD	(MASK),A	;
	LD	A,005H		;SETUP DMA FOR WRITE
	LD	(DMAS3F),A	;
	LD	A,0ACH		;WRITE COMMAND

SRW1:
	LD	(CMD),A		;
	LD	HL,FPYBUF	;
	LD	(DMASA),HL	;
	LD	A,(NEWDSK)	;
	CALL	DSKSEL		;SELECT DRIVE FOR I/O
	LD	A,(ERFLAG)	;CHECK FOR SELECT ERROR
	OR	A		;
	RET	NZ		;RETURN IF ERROR

SRW2:
	LD	A,10		;SET NUMBER OF TRIALS
	LD	(T_RETRIES),A	;SAVE FOR RETRY ROUTINE
	XOR	A
	LD	(HOME_TOGGLE),A	;FORCE HOME PRIOR TO EACH RETRY

LOAD_HEAD:
	IN	A,(008H)	;IS HEAD LOADED ??
	AND	00000010B	;CHECK IT....
	JR	NZ,REMOVE_LD	;YES, ITS LOADED, DONT RELOAD....
	IN	A,(005H)	;DUMMY SEEK TO START HEAD LOADING
	OUT	(007H),A	;KEEP IT SHORT....
	LD	A,01AH		;START HEAD LOADING
	CALL	FINTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND
LDH1:	CALL	FPYWAIT		;WAIT FOR I/O TO COMPLETE
	LD	A,(STATUS)	;HOW DID IT GO?
	AND	10011000B	;CHECK
	JR	NZ,CHECKIT	;DO NOT GO ON IF ERROR

	LD	C,16		;WAIT HERE FOR 16 MS
	CALL	DELAY		;CALL WAIT ROUTINE
	CALL	POINT		;REESTABLISH TRACK REGISTER
	LD	(HL),254	;ENSURE FURTHER SEEK AND DE
	JR	TRKTST		;

REMOVE_LD:
	LD	HL,CMD		;POINT TO I/O COMMAND
	LD	A,11111011B	;REMOVE HEAD LOAD BIT
	AND	(HL)		;DO IT....
	LD	(HL),A		;SAVE IT BACK INTO CMD

TRKTST:
	CALL	POINT		;RESTORE TRACK REGISTER POINTER
	LD	A,(NEWTRK)	;GET NEW TRACK NUMBER
	LD	(TRAKNO),A	;SAVE IN COMMON PLACE
	CP	(HL)		;SAME AS LAST TIME ??
	JR	Z,FSECSET	;YES, DONT BOTHER WITH SEEK
	LD	(HL),A		;SAVE IT
	OUT	(007H),A	;ALSO SEND IT TO CONTROLLER

	CALL	DBL_UPDATE	;DOUBLE SIDED SUPPORT

FLOPPY_SEEK:
	LD	A,01AH		;SEEK COMMAND WITH HEAD LOA
	CALL	FINTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND
FPS1:	CALL	FPYWAIT		;WAIT FOR I/O TO COMPLETE
	LD	A,(STATUS)	;HOW DID IT GO?
	AND	10011000B	;CHECK
	JR	NZ,CHECKIT	;DO NOT GO ON IF ERROR

	LD	C,16		;SET FOR 16 MS DELAY
	CALL	DELAY		;
FSECSET:
	LD	A,(NEWSEC)	;SET SECTOR
	LD	(SECTNO),A	;SAVE IN COMMONN PLACE
	OUT	(006H),A	;

	CALL	FLOPPYIO	;DO I/O
CHECKIT:
	CALL	CHECK_STAT	;CHECK STATUS OF I/O
	LD	A,(ERFLAG)	;SETUP TO RETURN TO BDOS
	RET	Z		;EITHER OK OR PERMANENT ERROR
	JR	LOAD_HEAD	;ERROR, JUST RETRY THIS SAME I/O

;-----------------------------------------------------------------------
;
;	THIS IS THE ROUTINE THAT DOES THE FLOPPY DISK I/O
;
;-----------------------------------------------------------------------

FLOPPYIO:
	IF	~~DMA
	LD	HL,066H		;MOVE DATA FROM 066H TO SAVE
	LD	DE,SAVE1		;
	LD	BC,004H		;
	LDIR			;MOVE IT

	LD	HL,NMIRTN	;SET NMI ROUTINE TO NMI ADDRESS
	LD	DE,066H		;
	LD	BC,004H		;
	LDIR			;MOVE IT

	LD	A,(CMD)		;IS IT A WRITE ??
	AND	20H		;
	JP	Z,FRD		;NO, LEAVE INI CMD IN LOW MEMORY
	LD	HL,067H		;POINT TO COMMAND AREA
	LD	(HL),0A3H	;MAKE IT AN OTI CMD....
FRD	EQU	$		;LABEL
	ENDIF

	IF	DMA
	LD	HL,DMAS1	;INITIALIZE DMA
	LD	BC,0600H	;
	OTIR			;WRITE TO DMA
	LD	HL,DMAS2F	;
	LD	BC,0400H	;
	OTIR			;WRITE TODMA
	LD	HL,DMAS3	;
	LD	BC,0700H	;
	OTIR			;WRITE TO DMA
	ENDIF

	LD	C,007H		;PORT ADDRESS FOR I/O
	LD	HL,FPYBUF	;DMA ADDRESS
	LD	A,(CMD)		;I/O COMMAND
	CALL	FINTFIX		;CLEAR ANY PENDING INTERRUP
;				;AND ISSUE COMMAND

	IF	~~DMA
	LD	HL,SAVE1	;SETUP TO REPLACE DATA
	LD	DE,066H	;COPIED FROM NMI LOCATION
	LD	BC,004H		;
	LDIR			;MOVE IT....
	ENDIF

	RET			;RETURN, I/O COMPLETED

;-----------------------------------------------------------------------
;
;	WE WILL NOW CHECK THE STATUS OF THE I/O OPERATION
;		RETURN WITH CONDITION CODE ZERO = NO RETRY
;		RETURN WITH CONDITION CODE NON ZERO = RETRY
;
;-----------------------------------------------------------------------

CHECK_STAT:
	LD	HL,ERFLAG	;POINT TO ERROR INDICATOR
	LD	(HL),000H		;ASSUME OK
	LD	HL,STATUS	;CHECK STATUS
	LD	A,(MASK)		;MASK FOR UNWANTED BIT REMOVAL
	AND	(HL)		;
	LD	(HL),A		;SAVE CLEANED STATUS
	RET	Z;OK, SO RETURN

CHKS0:
	CALL	RETMOD		;
	CP	003H		;HARD DISK ??
	LD	HL,STATUS	;
	LD	A,(HL)		;RELOAD STATUS BYTE
	JR	NC,CHKS2	;YES, CHECK FOR DRIVE READY

CHKS1:
	CP	080H		;IS FLOPPY DISK NOT READY ???
	JR	Z,BADIO		;YES, DONT BOTHER WITH RETRY OR MESSAGE
	JR	CHKS3		;GO TO BAD MESSAGE ROUTINE

CHKS2:
	CP	000H		;IS HARD DISK NOT READY ??
	JR	Z,BADIO		;YES, BYPASS ERROR MESSAGE AND COUNTING
	AND	01000000B	;IS IT WRITE FAULT ??
	JR	Z,CHKS3		;NO, CONTINUE ON
	CALL	POINT		;POINT TO TRACK REGISTER
	EX	DE,HL		;POINT TO SELECT MASK
	LD	A,(HL)		;
	OR	01000000B	;TURN ON WRITE FAULT CLEAR
	OUT	(020H),A		;
	LD	A,(HL)		;RESET CLEAR
	OUT	(020H),A		;
	LD	C,20		;DELAY JUST TO BE SAFE
	CALL	DELAY		;

CHKS3:
	LD	A,(HOME_TOGGLE)
	OR	A		;IS A HOME NEEDED ON THIS RETRY?
	JR	NZ,CHKS4		;IF NOT...BRANCH

	LD	A,(STATUS)		;SAVE STATUS OVER HOME
	PUSH	AF		;
	CALL	HOME		;RESET DEVICE TO HOME
	POP	AF		;
	LD	(STATUS),A		;SAVE FOR ERROR MESSAGE

CHKS4:
	LD	DE,TCNT		;BUMP TEMP ERROR COUNT
	CALL	ADDERRORS	;
	LD	HL,T_RETRIES	;PICKUP RETRY COUNT
	DEC	(HL)		;DECREMENT COUNT OF RETRIES
	RET	NZ		;

	LD	DE,PCNT		;BUMP PERMANENT ERROR COUNT
	CALL	ADDERRORS	;

BADIO:
	LD	HL,ERFLAG	;SET PERMANENT ERROR
	LD	(HL),001H		;DO IT....
	XOR	A		;RESET TO PRECLUDE RETRIES
	RET			;RETURN TO CALLER

ADDERRORS:
	LD	HL,(DISKNO)		;BUMP COUNT OF DISK ERRORS
	LD	H,000H		;
	ADD	HL,DE		;POINT TO ERROR REGISTER
	INC	(HL)		;
	RET			;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	THIS IS HARD DISK WAIT ENTRY
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WAIT0:
	PUSH	BC		; SAVE RETRY COUNT
	LD	C,FLAGWT	; FUNCTION FLAG WAIT
	LD	E,HDFLAG	; DEVICE IS HARD DISK
	CALL	XDOS
	POP	BC		; RESTORE RETRY COUNTER IN

;	READ OR WRITE IS OK, ACCUMULATOR CONTAINS ZERO

	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	THE FOLLOWING CODE GUARANTEES THAT HARD DISK FLAG I
;	IT APPEARS THAT WE OCCASIONALLY GET FLAG SET AS A R
;	OF AN INTERRUPT FROM THE HARD DISK, WHEN WE DO
;	NOT EXPECT IT.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INTFIX:
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL

	LD	C,FLAGST
	LD	E,HDFLAG
	CALL	XDOS		;EITHER FLAG 5 WILL BE SET
;				;IT IS ALREADY SET - IN WHI
;				;THIS REQUEST WILL BE IGNOR

	LD	C,FLAGWT
	LD	E,HDFLAG
	CALL	XDOS		;NOW CLEAR THE FLAG

	POP	HL
	POP	DE
	POP	BC
	POP	AF		;RESTORE REGISTERS

	OUT	(023H),A		;ISSUE COMMAND TO HARD DISK

	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	THIS IS FLOPPY DISK WAIT ENTRY
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FPYWAIT:
	PUSH	BC	;SAVE RETRY COUNT
	PUSH	HL
	LD	C,FLAGWT	; FUNCTION IS FLAG WAIT
	LD	E,FPYFLAG	; WAIT FOR FLOPPY
	CALL	XDOS
	PUSH	AF
	LD	A,(FPYTIME)		;DID WD1791 GO TO SLEEP?
	OR	A		;
	JR	NZ,NOFPYRST	;IF STILL AWAKE, SKIP RESET

	IN	A,(009H)		;GET CURRENT BANK NUMBER
	AND	00011000B	;REMOVE OTHER INFO
	OUT	(009H),A		;RESET WD1791
	LD	C,1		;DELAY 1 MILLISEC
	CALL	DELAY		;
	OR	00000010B	;END RESET
	OUT	(009H),A		;
	LD	A,(NEWDSK)		;MAKE SURE CURRENT DISK AND
	LD	(DISKNO),A		; THE SAME
NOFPYRST:
	POP	AF
	POP	HL
	POP	BC		;RESTORE RETRY COUNT IN <C>

	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	THE FOLLOWING CODE GUARANTEES THAT FLOPPY DISK FLAG
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FINTFIX:
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,FLAGST
	LD	E,FPYFLAG
	CALL	XDOS

	LD	C,FLAGWT
	LD	E,FPYFLAG
	CALL	XDOS

	LD	HL,00103H	;SETTIME OUT INDICATOR ON |
	LD	(FPYTIME),HL		;TIME TO BE BETWEEN 2 AND

	POP	HL
	POP	DE
	POP	BC
	POP	AF

	OUT	(004H),A		;ISSUE COMMAND TO FLOPPY DI

	RET

	if	~~MPM20
FPYTIME:
	DW	0

FPYTCNT:
	DW	0
	endif


;-----------------------------------------------------------------------
;
;	THIS IS THE DELAY ROUTINE. IT WILL LOOP HERE FOR THE
;	NUMBER OF MILLISECONDS SPECIFIED IN REGISTER C.
;
;-----------------------------------------------------------------------

DELAY:
DEL1:	LD	B,100		;FORCE DELAY FOR 1 MILLISECOND
DEL2:	NOP			;INSTRUCTIONS TO FILL IN TIME
	ADD	HL,HL		;
	ADD	HL,HL		;
	DEC	B		;AT ONE MILLISECOND YET ??
	JP	NZ,DEL2		;NO, KEEP ON LOOPING
	DEC	C		;END OF REQUESTED INTERVAL YET ??
	JP	NZ,DEL1		;NO, KEEP ON
	RET			;RETURN TO CALLER

;********************************************
;* NOTE: THE INITIALIZATION CODE WILL BE
;*   OVERWRITTEN BY DIRBUF & FPYBUF
;********************************************

	if	~~MPM20
DIRBUF	EQU	$
	endif

;-----------------------------------------------------------------------
;
;	DISK CONFIGURATION TABLE
;
;-----------------------------------------------------------------------

	IF	HARDSK
						;     PIN C

DSCN0:	DB	00H,00H,00H,00H,00H,00H,00H,00H
	DB	10H,00H,00H,00H,00H,00H,10H,00H		;
	DB	90H,90H,90H,00H,00H,00H,00H,00H		;
	DB	00H,00H,00H,00H,00H,00H,00H,00H
	DB	10H,00H,00H,20H,00H,00H,10H,20H		;
	DB	00H,00H,00H,00H,00H,00H,00H,00H
	DB	90H,90H,90H,20H,00H,00H,00H,20H		;
	DB	90H,90H,90H,0A0H,0A0H,0A0H,0H,0H	;
	ENDIF

;-----------------------------------------------------------------------
;
;	SET UP DISK CONFIGURATON
;
;	[ THIS CODE EXECUTED ONLY ONCE ]
;
;-----------------------------------------------------------------------
;
SDCONF:	LD	HL, SEL0+2	;POINT TO DRIVE C:
	LD	A,(MPARMS)		;
	AND	05H		; TEST FOR FOUR FLOPPIES
	JP	SDDBL		;  YES SKIP THE ZAP
	LD	(HL),A		;
	INC	HL		; ZAP C: AND D:
	LD	(HL),A		;
SDDBL:
	LD	DE,SEL0+4	;POINT TO DRIVE E:
	IF	HARDSK
	IN	A,(025H)		;READ CONFIGURATION PORT
	AND	07H		;STRIP OFF HIGH PART
	RLA			;
	RLA			;
	RLA			;
	LD	B,0		;
	LD	C,A		;POINT TO CONFIGURATION TAB
	LD	HL,DSCN0	;
	ADD	HL,BC		;  INDEX TO RIGHT ENTRY
	LD	B,8		;
SDL1:	LD	A,(HL)		; CHANGE ALL SELECT MASKS
	LD	(DE),A		;
SDOK:	INC	DE		; NEXT
	INC	HL		; DRIVE
	DJNZ	SDL1		;
	ENDIF
	IF	~~HARDSK
	EX	DE,HL		;
	LD	B,8		;
	XOR	A		;
SDL2:	LD	(HL),A		; ZAP ALL HARD DRIVES
	INC	HL		;
	DJNZ	SDL2		;
	ENDIF			;

	RET

INITEND	EQU	$

XETMOD:	PUSH	HL		;SAVE MODE BYTE ADDRESS
	LD	A,C		;SETUP FOR DENSITY CHANGE
	OR	A		;
	LD	C,000H		;ASSUME SINGLE DENSITY MODE....
	JR	Z,XETSEL		;VERIFY ASSUMPTION
	LD	C,001H		;SET FOR DOUBLE DENSITY MODE....
XETSEL:	CALL	SETDEN		;SET DENSITY BASED ON LOW BIT
	POP	HL		;RESTORE
	LD	L,(HL)		;PICKUP MODE AGAIN
	LD	H,000H		;FOR SINGLE BYTE PRECISION
	LD	A,L		;SAVE MODE IN ACCUMULATOR FOR LATER
	ADD	HL,HL		;* 2
	ADD	HL,HL		;* 4
	PUSH	HL		;SAVE * 4
	ADD	HL,HL		;* 8
	POP	DE		;REGAIN * 4
	ADD	HL,DE		;* 12
	LD	DE,MODL0		;FIRST MODEL DPE
	ADD	HL,DE		;POINT TO THIS ONE
	EX	DE,HL		;SETUP TEMPORARILY AS DESTINATION
	LD	HL,(DPEPTR)		;ADDRESS OF CURRENTLY SELECTED DPE
	EX	DE,HL		;SETUP TO ALTER
	LD	BC,12		;LENGTH FOR MOVE
	LDIR			;DO MOVE
	RET			;RETURN TO CALLER

;-----------------------------------------------------------------------
;
;	THE FOLLOWING AREA CONTAINS THE DISK/WORK SAVE AREAS
;	USED BY THE CBIOS IN THE NORMAL COURSE OF ACTIVITY.
;
;-----------------------------------------------------------------------

	if	MPM20
;tempbuf	equ	(DIRBUF-base)+128
	else
TEMPBUF	EQU	(DIRBUF-BASE)+256
	ORG TEMPBUF+((INITEND-BASE)/TEMPBUF)*((INITEND-BASE
	endif

BEGDAT	EQU	$			;START OF BDOS AREAS
;DIRBUF:	DS	128	;OVERLAYS SYSTEMINIT CODE
ALV0:	DS	31
CSV0:	DS	32
ALV1:	DS	31
CSV1:	DS	32
ALV2:	DS	31
CSV2:	DS	32
ALV3:	DS	31
CSV3:	DS	32
	IF	HARDSK
ALV4:	DS	64
CSV4:	DS	0
ALV5:	DS	64
CSV5:	DS	0
ALV6:	DS	64
CSV6:	DS	0
ALV7:	DS	64
CSV7:	DS	0
ALV8:	DS	64
CSV8:	DS	0
ALV9:	DS	64
CSV9:	DS	0
ALVA:	DS	36
CSVA:	DS	0
ALVB:	DS	36
CSVB:	DS	0
	endif

	if	MDISK
ALVC:	DS	32			;VIRTUAL DISK
CSVC:	DS	0
	endif

	if	~~MPM20
	if	HARDSK
	DS	1			;MUST PRECEDE HSTBU
HSTBUF:	DS	1024			;HOST BUFFER AREA
	DS	1			;MUST FOLLOW HSTBUF
	ENDIF

FPYBUF	EQU	DIRBUF+128		;FLOPPY I/O BUFFER
	endif

NEWDSK:	DS	1			;SEEKDISK NUMBER
NEWTRK:	DS	2			;SEEK TRACK NUMBER
NEWSEC:	DS	1			;SEEK SECTOR NUMBER

HSTDSK:	DS	1			;HOST DISK NUMBER
HSTTRK:	DS	2			;HOST TRACK NUMBER
HSTSEC:	DS	1			;HOST SECTOR NUMBER

NEWHST:	DS	1			;SEEK SHR SECSHF
HSTACT:	DS	1			;HOST ACTIVE FLAG
HSTWRT:	DS	1			;HOST WRITTEN FLAG

UNACNT:	DS	1			;UNALLOCATED RECORD COUNT
UNADSK:	DS	1			;LAST UNALLOCATED DISK
UNATRK:	DS	2			;LAST UNALLOCATED TRACK
UNASEC:	DS	1			;LAST UNALLOCATED SECTOR

ERFLAG:	DS	1			;ERROR REPORTING
RSFLAG:	DS	1			;READ SECTOR FLAG
READOP:	DS	1			;1 IF READ OPERATION
WRTYPE:	DS	1			;WRITE OPERATION TYPE

CMD:	DB	0			;COMMANDS FOR NEXT I/O
MASK:	DB	0			;STATUS MASKS BUFFER FOR DISK I/O
STATUS:	DB	0			;STATUS SAVE LOCATION FOR DISK I/O

SAVE1:	DB	000H,000H,000H,000H	;SAVE AREA FOR NMI ROUTINE
P_RETRIES: DB	000H			;COUNTER FOR PERMANENT ERRORS
T_RETRIES: DB	000H			;COUNTER FOR TEMPORARY ERRORS
HOME_TOGGLE:
	DB	000H			;INDICATOR TO TELL HARD DISK ERROR RECOVERY
;					;.. IF HOME SHOULD BE DONE BEFORE NEXT I/O

	if	MPM20

; *********************************************************
; *
; *	      M P / M  2 . 0   C O M M O N   B A S E
; *
; *********************************************************

COMMONBASE:
	 jp	COLDSTART
SWTUSER: jp	$-$
SWTSYS:	 jp	$-$
PDISP:	 jp	$-$
XDOS:	 jp	$-$
SYSDAT:	 dw	$-$
COLDSTART:
WARMSTART:
	LD	C,0			; SEE SYSTEM INIT
					; COLD & WARM START INCLUDE
					; FOR COMPATIBILITY WITH CP
	JP	XDOS			; SYSTEM RESET, TERMINATE P

RTNEMPTY:
	xor	a
	ret

NULL_INT:
	EI
	RETI
	endif

;-----------------------------------------------------------------------
;
;	CENTRONICS PRINTER ROUTINE (WITH SEPARATE BUSY TEST FOR SPOOLER)
;
;-----------------------------------------------------------------------

CNSTAT:
	LD	A,001H		;TO SET STROBE HIGH
	OUT	(010H),A		;
	IN	A,(010H)		;READ PRINTER STATUS
	AND	020H		;REMOVE ALL BUT BUSY BIT
	LD	A,0FFH		;ASSUME NOT BUSY
	RET	Z		;CHECK ASSUMPTION
	XOR	A		;SET TO SHOW STILL BUSY
	RET			;
;
;	WE WILL NOW PERFORM THE PRINT FUNCTION BUSY TEST
;
CNTBSY:
	CALL	CNSTAT		;CHECK STATUS OF PRINTER
	CP	0FFH		;READY ??
	JR	NZ,CNTBSY		;NO, WAIT HERE
	RET			;

CLIST:
	CALL	CNSTAT		;IS PRINTER READY NOW?
	OR	A
	JR	NZ,CLIST1		;IF READY, SKIP POLL

	PUSH	BC		;
	LD	C,POLL		; POLL DEVICE
	LD	E,PLLPT	;  PRINTER
	CALL	XDOS		;WAIT FOR PRINTER TO FREE U
	POP	BC		;

CLIST1:
	LD	A,C		;CHARACTER TO PRINT
	OUT	(011H),A		;WRITE IT TO DATA PORT
	LD	A,000H		;TO FORCE STROBE LOW
	OUT	(010H),A		;
	LD	A,001H		;TO FORCE STROBE HIGH
	OUT	(010H),A		;
	RET			;

;-----------------------------------------------------------------------
;
;	DISK INTERRUPT ROUTINE
;
;-----------------------------------------------------------------------

FLOPPY_INT:
	LD	(SVDHL),HL
	LD	HL,FDINTH
	JP	INTINIT
FDINTH:
	IN	A,(004H)		;GET STATUS
	LD	(STATUS),A		;SAVE FOR I/O ROUTINE
	LD	A,0		;STOP TIMING OF RESPONSE TO
	LD	(FPYTIME+1),A	;
	LD	E,FPYFLAG	;SHOW I/O COMPLETED
	JR	HDSTFLG

HARD_INT:
	LD	(SVDHL),HL
	LD	HL,HDINTH
	JP	INTINIT
HDINTH:
	IN	A,(024H)		;GET STATUS
	LD	(STATUS),A		;SAVE FOR CHECK LATER

	XOR	A
	OUT	(023H),A		;RESET INTERRUPT BY RELOADI

	LD	E,HDFLAG	;SHOW I/O COMPLETED
HDSTFLG:
	LD	C,FLAGST
	CALL	XDOS
	JP	INTDONE

;-----------------------------------------------------------------------
;
;	CONSOLE DISPLAY ROUTINES
;
;-----------------------------------------------------------------------

CONST:				; CONSOLE STATUS
	CALL	PTBLJMP		; COMPUTE AND JUMP TO HNDLR
	DW	PT0ST		; CONSOLE #0 STATUS ROUTINE
	DW	PT1ST		; CONSOLE #1 STATUS ROUTINE
	DW	PT2ST		; CONSOLE #2 STATUS ROUTINE
	DW	PT3ST		; CONSOLE #3 STATUS ROUTINE

CONIN:				; CONSOLE INPUT
	CALL	PTBLJMP		; COMPUTE AND JUMP TO HNDLR
	DW	PT0IN		; CONSOLE #0 INPUT
	DW	PT1IN		; CONSOLE #1 INPUT
	DW	PT2IN		; CONSOLE #2 INPUT
	DW	PT3IN		; CONSOLE #3 INPUT

CONOUT:				; CONSOLE OUTPUT

	CALL	PTBLJMP		; COMPUTE AND JUMP TO HNDLR
	DW	PT0OUT		; CONSOLE #0 OUTPUT
	DW	PT1OUT		; CONSOLE #1 OUTPUT
	DW	PT2OUT		; CONSOLE #2 OUTPUT
	DW	PT3OUT		; CONSOLE #3 OUTPUT

PTBLJMP:			; COMPUTE AND JUMP TO HANDLER
				; D = CONSOLE #
				; DO NOT DESTROY <D>
	LD	A,D
	CP	NMBCNS
	JR	C,TBLJMP
	POP	AF		; THROW AWAY TABLE ADDRESS
	XOR	A
	RET
TBLJMP:				; COMPUTE AND JUMP TO HANDLER
				; A = TABLE INDEX
	ADD	A,A		; DOUBLE TABLE INDEX FOR ADR OFFST
	POP	HL		; RETURN ADR POINTS TO JUMP TBL
	LD	E,A
	LD	D,0
	ADD	HL,DE		; ADD TABLE INDEX * 2 TO TBL BASE
	LD	E,(HL)		; GET HANDLER ADDRESS
	INC	HL
	LD	D,(hl)
	EX	DE,HL
	JP	(HL)		; JUMP TO COMPUTED CNS HANDLER

;-----------------------------------------------------------------------
;
;	SERIAL PORT ADDRESS EQUATES
;
;-----------------------------------------------------------------------

DATA0	EQU	01CH		;CONSOLE #0 DATA
STS0	EQU	DATA0+1		;CONSOLE #0 STATUS
DATA1	equ	02CH		;CONSOLE #1 DATA
STS1	EQU	DATA1+1		;CONSOLE #1 STATUS
DATA2	EQU	02EH		;CONSOLE #2 DATA
STS2	EQU	DATA2+1		;CONSOLE #2 STATUS
DATA3	EQU	02AH		;CONSOLE #3 DATA
STS3	EQU	DATA3+1		;CONSOLE #3 STATUS
LPTPRT0	EQU	01EH		;PRINTER #0 DATA
LPTSTS0	EQU	LPTPRT0+1	;PRINTER #0 STATUS
LPTPRT1	EQU	028H		;PRINTER #1 DATA
LPTSTS1	EQU	LPTPRT1+1	;PRINTER #1 STATUS


;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 0  INPUT
;
;-----------------------------------------------------------------------

POLCI0:
PT0ST:				; TEST CONSOLE STATUS
	XOR	A		;  RETURN  0FFH IF READY
	OUT	(STS0),A		;          000H IF NOT
	IN	A,(STS0)		;
	AND	1		;  RX CHAR ?
	RET	Z		;   NO
	LD	A,0FFH		;   YES - SET FLAG
	RET			;

;-----------------------------------------------------------------------
;
;	CONSOLE  # 0  INPUT
;
;-----------------------------------------------------------------------
;
PT0IN:				; RETURN CHAR IN REG A
	CALL	POLCI0		;IS IT READY NOW?
	OR	A		;
	JR	NZ,PT0IN1		;IF READY, SKIP POLL
	LD	C,POLL		;
	LD	E,PLCI0		; POLL CONSOLE #0 INPUT
	CALL	XDOS		;
PT0IN1:	IN	A,(DATA0)		; READ CHARACTER
	AND	7FH		; STRIP PARITY
	RET			;

;-----------------------------------------------------------------------
;
;	CONSOLE  # 0  OUTPUT
;
;-----------------------------------------------------------------------

PT0OUT:				; REG C = CHAR TO OUTPUT
	CALL	POLCO0		;IS IT READY NOW?
	OR	A		;
	JR	NZ,PT0OUT1		;IF READY, SKIP POLL
	PUSH	BC		;
	LD	C,POLL		;
	LD	E,PLCO0		;
	CALL	XDOS		; POLL CONSOLE #0 OUTPUT
	POP	BC		;
PT0OUT1:
	LD	A,C		;
	OUT	(DATA0),A		; TRANSMIT CHARACTER
	RET			;
;
;
;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 0  OUTPUT
;
;-----------------------------------------------------------------------
;
POLCO0:				; RETURN 0FFH IF READY
	LD	A,10H		;        000H IF NOT
	OUT	(STS0),A		; RESET INT BIT
	IN	A,(STS0)		; READ STATUS
	AND	0CH		; MASK FOR DTR AND TXE
	CP	0CH		; MUST HAVE BOTH
	LD	A,0		;
	RET	NZ		; RETURN NOT READY
	DEC	A		;CHANGE "A" TO 0FFH
	RET			; RETURN READY

;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 1  INPUT
;
;-----------------------------------------------------------------------

POLCI1:
PT1ST:				; TEST CONSOLE STATUS
	XOR	A		;  RETURN 0FFH IF READY
	OUT	(STS1),A		;	  000H IF NOT
	IN	A,(STS1)		;
	AND	1		;  RX CHAR ?
	RET	Z		;   NO
	LD	A,0FFH		;   YES - SET FLAG
	RET			;

;-----------------------------------------------------------------------
;
;	CONSOLE  # 1  INPUT
;
;-----------------------------------------------------------------------

PT1IN:				; RETURN CHAR IN REG A
	CALL	POLCI1		;READY NOW?
	OR	A		;
	JR	NZ,PT1IN1		;IF READY, SKIP POLL
	LD	C,POLL		;
	LD	E,PLCI1		; POLL CONSOLE #1 INPUT
	CALL	XDOS		;
PT1IN1:	IN	A,(DATA1)		; READ CHARACTER
	AND	7FH		; STRIP PARITY
	RET			;
;
;
;-----------------------------------------------------------------------
;
;	CONSOLE  # 1  OUTPUT
;
;-----------------------------------------------------------------------
;
PT1OUT:				; REG C = CHAR TO OUTPUT
	CALL	POLCO1		;ARE WE READY NOW?
	OR	A		;
	JR	NZ,PT1OUT1		;IF READY, SKIP POLL
	PUSH	BC		;
	LD	C,POLL		;
	LD	E,PLCO1		;
	CALL	XDOS		; POLL CONSOLE #1 OUTPUT
	POP	BC		;
PT1OUT1:
	LD	A,C		;
	OUT	(DATA1),A		; TRANSMIT CHARACTER
	RET			;

;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 1  OUTPUT
;
;-----------------------------------------------------------------------

POLCO1:				; RETURN 0FFH IF READY
	LD	A,10H		;	 000H IF NOT
	OUT	(STS1),A		; RESET INT BIT
	IN	A,(STS1)		; READ STATUS
	AND	0CH		; MASK FOR DTR AND TXE
	CP	0CH		; MUST HAVE BOTH
	LD	A,0		;
	RET	NZ		; RETURN NOT READY
	DEC	A		;CHANGE "A" TO 0FFH
	RET			; RETURN READY

;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 2  OUTPUT
;
;-----------------------------------------------------------------------

POLCI2:
PT2ST:				; TEST CONSOLE STATUS
	XOR	A		;  RETURN 0FFH IF READY
	OUT	(STS2),A		;	  000H IF NOT
	IN	A,(STS2)		;
	AND	1		;  RX CHAR ?
	RET	Z		;   NO
	LD	A,0FFH		;   YES - SET FLAG
	RET			;
;
;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 2  INPUT
;
;-----------------------------------------------------------------------
;
PT2IN:				; RETURN CHAR IN REG A
	CALL	POLCI2		;READY NOW?
	OR	A		;
	JR	NZ,PT2IN1		;IF READY, SKIP POLL
	LD	C,POLL		;
	LD	E,PLCI2		; POLL CONSOLE #2 INPUT
	CALL	XDOS		;
PT2IN1:	IN	A,(DATA2)		; READ CHARACTER
	AND	7FH		; STRIP PARITY
	RET			;
;
;-----------------------------------------------------------------------
;
;	CONSOLE  # 2  INPUT
;
;-----------------------------------------------------------------------
;
PT2OUT:				; REG C = CHAR TO OUTPUT
	CALL	POLCO2		;READY NOW?
	OR	A		;
	JR	NZ,PT2OUT1		;IF READY, SKIP POLL
	PUSH	BC		;
	LD	C,POLL		;
	LD	E,PLCO2		;
	CALL	XDOS		; POLL CONSOLE #2 OUTPUT
	POP	BC		;
PT2OUT1:
	LD	A,C		;
	OUT	(DATA2),A		; TRANSMIT CHARACTER
	RET			;
;
;
;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 2  OUTPUT
;
;-----------------------------------------------------------------------
;
POLCO2:				; RETURN 0FFH IF READY
	LD	A,10H		;	 000H IF NOT
	OUT	(STS2),A		; RESET INT BIT
	IN	A,(STS2)		; READ STATUS
	AND	0CH		; MASK FOR DTR AND TX
	CP	0CH		; MUST HAVE BOTH
	LD	A,0		;
	RET	NZ		; RETURN NOT READY
	DEC	A		;CHANGE "A" TO 0FFH
	RET			; RETURN READY

;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 3  INPUT
;
;-----------------------------------------------------------------------

POLCI3:
PT3ST:				; TEST CONSOLE STATUS
	XOR	A		;  RETURN  0FFH IF READY
	OUT	(STS3),A		;          000H IF NOT
	IN	A,(STS3)		;
	AND	1		;  RX CHAR ?
	RET	Z		;   NO
	LD	A,0FFH		;   YES - SET FLAG
	RET			;

;-----------------------------------------------------------------------
;
;	CONSOLE  # 3  INPUT
;
;-----------------------------------------------------------------------

PT3IN:				; RETURN CHAR IN REG A
	CALL	POLCI3		;READY NOW?
	OR	A		;
	JR	NZ,PT3IN1		;IF READY, SKIP POLL
	LD	C,POLL		;
	LD	E,PLCI3	; POLL CONSOLE #3 INPUT
	CALL	XDOS		;
PT3IN1:	IN	A,(DATA3)		; READ CHARACTER
	AND	7FH		; STRIP PARITY
	RET			;
;
;
;-----------------------------------------------------------------------
;
;	CONSOLE  # 3  INPUT
;
;-----------------------------------------------------------------------
;
PT3OUT:				; REG C = CHAR TO OUTPUT
	CALL	POLCO3		;READY NOW?
	OR	A		;
	JR	NZ,PT3OUT1	;IF READY, SKIP POLL
	PUSH	BC		;
	LD	C,POLL		;
	LD	E,PLCO3		;
	CALL	XDOS		; POLL CONSOLE #3 OUTPUT
	POP	BC		;
PT3OUT1:
	LD	A,C		;
	OUT	(DATA3),A		; TRANSMIT CHARACTER
	RET
;
;
;-----------------------------------------------------------------------
;
;	POLL CONSOLE  # 3  INPUT
;
;-----------------------------------------------------------------------
;
POLCO3:				; RETURN 0FFH IF READY
	LD	A,10H		;	 000H IF NOT
	OUT	(STS3),A		; RESET INT BIT
	IN	A,(STS3)		; READ STATUS
	AND	0CH		; MASK FOR DTR AND TXE
	CP	0CH		; MUST HAVE BOTH
	LD	A,0		;
	RET	NZ		; RETURN NOT READY
	DEC	A		;CHANGE "A" TO 0FFH
	RET			; RETURN READY

;-----------------------------------------------------------------------
;
;	LINE PRINTER  #0  DRIVER
;
;-----------------------------------------------------------------------
;
LIST:				;LIST OUTPUT #0
	CALL	POLLPT
	OR	A		;IS PRINTER READY NOW?
	JR	NZ,LIST1		;IF READY, SKIP POLL

	PUSH	BC
	LD	C,POLL		; POLL PRINTER STATUS
	LD	E,PLLPT		;
	CALL	XDOS		;
	POP	BC		;

LIST1:
	LD	A,C		; CHARACTER TO PRINT
	OUT	(LPTPRT0),A		;
	RET			;

;
;-----------------------------------------------------------------------
;
;	POLL PRINTER OUTPUT
;
;-----------------------------------------------------------------------
;
POLLPT:				; RETURN 0FFH IF READY
	LD	A,10H		;	 000H IF NOT
	OUT	(LPTSTS0),A		; RESET INT BIT
	IN	A,(LPTSTS0)		; READ STATUS
	AND	0CH		; MASK FOR DTR AND TXE
	CP	0CH		; MUST HAVE BOTH
	LD	A,0		;
	RET	NZ		; RETURN NOT READY
	DEC	A		;CHANGE "A" TO 0FFH
	RET			; RETURN READY
;

;
;  MP/M 1.0   EXTENDED I/O SYSTEM
;
;

POLLDEVICE:
				; REG C = DEVICE # TO BE POLLED
				; RETURN 0FFH IF READY,
				;        000H IF NOT
	LD	A,C
	CP	NMBDEV
	JR	C,DEVOK
	LD	A,NMBDEV; IF DEV # >= NMBDEV,
			; SET TO NMBDEV
DEVOK:
	CALL	TBLJMP	; JUMP TO DEV POLL CODE

DEVTBL:
	DW	POLLPT	; POLL PRINTER OUTPUT - THIS WILL P
			;  SPECIFIED PARALLEL PORT FOR PRIN
	DW	POLCO0	; POLL CONSOLE #0 OUTPUT
	DW	POLCO1	; POLL CONSOLE #1 OUTPUT
	DW	POLCO2	; POLL CONSOLE #2 OUTPUT
	DW	POLCO3	; POLL CONSOLE #3 OUTPUT
	DW	POLCI0	; POLL CONSOLE #0 INPUT
	DW	POLCI1	; POLL CONSOLE #1 INPUT
	DW	POLCI2	; POLL CONSOLE #2 INPUT
	DW	POLCI3	; POLL CONSOLE #3 INPUT
NMBDEV	EQU	($-DEVTBL)/2
	DW	RTNEMPTY; BAD DEVICE HANDLER

; SELECT / PROTECT MEMORY

SELMEMORY:
			; REG BC = ADR OF MEM DESCRIPTOR
			; BC -> BASE   1 BYTE,
			;	SIZE   1 BYTE,
			;	ATTRIB 1 BYTE,
			;	BANK   1 BYTE.
			;
			;   BIOS TABLE MODIFIED
	CP	20H	;
	JP	Z,$
	LD	HL,3	; POINT TO BANK
	ADD	HL,BC	;
	LD	A,(HL)	;  GET IT
	LD	(BANKNO),A	; SAVE BANK NUMBER
	RLA		;
	RLA		;
	RLA		;
	AND	018H	; MASK FOR PIO
	OR	MEMSK	;
	LD	(CURMEM),A	; STORE CURRENT BANK MASK
	OUT	(009H),A	; SET PIO
	RET

BANKNO:	DB	0	; LAST SELECTED MEMORY BANK NUMBER
CURMEM:	DB	0	; LAST SELECTED MEMORY BANK MASK

; START CLOCK

STARTCLOCK:
			; WILL CAUSE FLAG #1 TO BE SET
			;  AT EACH SYSTEM TIME UNIT TICK
	LD	A,0FFH
	LD	(TICKN),A
	RET

; STOP CLOCK

STOPCLOCK:
			; WILL STOP FLAG #1 SETTING AT
			; SYSTEM  TIME UNIT TICK
	XOR	A
	LD	(TICKN),A
	RET

; EXIT REGION

EXITREGION:
			; EI IF NOT PREEMPTED
	LD	A,(PREEMP)
	OR	A
	RET	NZ
	EI
	RET

; MAXIMUM CONSOLE NUMBER

MAXCONSOLE:
	LD	A,NMBCNS
	RET

; MP/M 1.0   INTERRUPT HANDLERS

DSPTCH	EQU	142

INT1HND:
			; INTERRUPT 1 HANDLER ENTRY POINT
			;
T20MS:
	LD	(SVDHL),HL
	LD	HL,TIMERINT
	JR	INTINIT
TIMERINT:
	LD	A,(TICKN)
	OR	A		; TEST TICKN, INDICATES
				;  DELAYED PROCESS(ES)
	JR	Z,NOTICKN
	LD	C,FLAGST
	LD	E,l
	CALL	XDOS		; SET FLAG #1 EACH TICK
NOTICKN:
	LD	HL,CNTX
	DEC	(HL)		; DEC TICK CNTR
	JR	NZ,NOT1SEC
	LD	A,125
	DEC	HL
	SUB	(HL)
	LD	(HL),A		; *** TOGGLE COUNT 62 <-> 6
	INC	HL
	LD	(HL),A		; *** ACTUAL #/SEC = 62.5
	LD	C,FLAGST
	LD	E,2
	CALL	XDOS		; SET FLAG #2 @ 1 SEC
	LD	HL,(FPYTIME)	;IS FLOPPY TIME CHECK IN EF
	LD	A,H		;
	OR	A		;
	JR	Z,NOT1SEC	;IF NOT IN EFFECT, FINISH
	DEC	L		;SUBTRACT A SECOND

	LD	(FPYTIME),HL	;SAVE FOR NEXT TIME
	JR	NZ,NOT1SEC	;IF NOT TOO LONG, FINISH
	LD	H,L		;ZERO OUT INDICATOR
	LD	(FPYTIME),HL	;PREVENT RE-ENTRY OF THIS R
	LD	C,FLAGST	;
	LD	E,FPYFLAG	;
	CALL	XDOS		;CAUSE I/O FOR FLOPPY TO CO
	LD	A,10010000B
	LD	(STATUS),A	;SHOW ERROR IN FLOPPY I/O
	LD	HL,(FPYTCNT)
	INC	HL		;COUNT TIMES WD1791 GOES TO
	LD	(FPYTCNT),HL	;

NOT1SEC:

INTDONE:
	XOR	A
	LD	(PREEMP),A	; CLEAR PREEMPTED FLAG
	POP	BC
	POP	DE
	LD	HL,(SVDSP)
	LD	SP,HL		; RESTORE STK PTR
	POP	AF
	LD	HL,(SVDRET)
	PUSH	HL
	LD	HL,PDISP	; MP/M DISPATCH
	PUSH	HL		; PUT ON STACK FOR RETURN
	LD	HL,(SVDHL)

; THE FOLLOWING DISPATCH CALL WILL FORCE ROUND ROBIN
;  SCHEDULING OF PROCESSES EXECUTING AT THE SAME PRIORITY
;  EACH 1/32ND OF A SECOND.
; NOTE: INTERRUPTS ARE NOT ENABLED UNTIL THE DISPATCHER
;  RESUMES THE NEXT PROCESS. THIS PREVENTS INTERRUPT
;  OVER-RUN OF THE STACKS WHEN STUCK OR HIGH FREQUENCY
;  INTERRUPTS ARE ENCOUNTERED.

	RETI			; DISPATCH

INTINIT:		;SAVE MACHINE STATE FOR INTRPT HNDL
	LD	(ADRINTHD),HL
	POP	HL
	LD	(SVDRET),HL
	PUSH	AF
	LD	HL,0
	ADD	HL,SP
	LD	(SVDSP),HL		; SAVE USERS STK PTR
	LD	SP,LSTINTSTK	; LCL STK FOR INTR HNDL
	PUSH	DE
	PUSH	BC

	LD	A,0FFH
	LD	(PREEMP),A		; SET PREEMPTED FLAG
	LD	HL,(ADRINTHD)
	JP	(HL)	;JUMP TO INTERRUPT HANDLER

;
; BIOS DATA SEGMENT
;
TOGCNT:	DB	62	; TOGGLE COUNTER 62 <-> 63
CNTX:	DB	62	; TICK CNTR TO 1 SEC
INTSTK:			; LOCAL INTRPT STK
	DW	0C7C7H,0C7C7H,0C7C7H,0C7C7H,0C7C7H
	DW	0C7C7H,0C7C7H,0C7C7H,0C7C7H,0C7C7H
	DW	0C7C7H,0C7C7H,0C7C7H,0C7C7H,0C7C7H
	DW	0C7C7H,0C7C7H,0C7C7H,0C7C7H,0C7C7H
LSTINTSTK:
ADRINTHD: DW	0	; INTERRUPT HANDLER ADDRESS
SVDHL:	DW	0	; SAVED REGS HL DURING INT HNDL
SVDSP:	DW	0	; SAVED SP DURING INT HNDL
SVDRET:	DW	0	; SAVED RETURN DURING INT HNDL
TICKN:	DB	0	; TICKING BOOLEAN,TRUE = DELAYED
PREEMP:	DB	0	; PREEMPTED BOOLEAN

	if	MPM20
FPYTIME:
	DW	0

FPYTCNT:
	DW	0
	endif

;-----------------------------------------------------------------------
;
;	THESE ARE THE DISK TYPE DEFINITION BLOCKS
;	EACH OF WHICH CORRESPONDS TO A PARTICULAR MODE.
;
;-----------------------------------------------------------------------

DPB0	EQU	$		;VERSION 2.0, IBM SINGLE DE
	DW	26		;SECTORS PER TRACK
	DB	3		;BLOCK SHIFT
	DB	7		;BLOCK SHIFT MASK
	DB	0		;EXTENT MASK
	DW	242		;DISK SIZE MINUS 1
	DW	63		;DIRECTORY MAX
	DB	192		;ALLOC0
	DB	0		;ALLOC1
	DW	16		;CHECK AREA SIZE
	DW	2		;OFFSET TO START TRACK

DPB1	EQU	$		;VERSION 2.0, IBM DOUBLE DE
	DW	52		;SECTORS PER TRACK
	DB	4		;BLOCK SHIFT
	DB	15		;BLOCK SHIFT MASK
	DB	1		;EXTENT MASK
	DW	242		;DISK SIZE MINUS 1
	DW	127		;DIRECTORY MAX
	DB	192		;ALLOC0
	DB	0		;ALLOC1
	DW	32		;CHECK AREA SIZE
	DW	2		;OFFSET TO START TRACK

DPB2	EQU	$		;VERSION 1.4 ALTOS DOUBLE D
	DW	48		;SECTORS PER TRACK
	DB	4		;BLOCK SHIFT
	DB	15		;BLOCK SHIFT MASK
	DB	0		;EXTENT MASK (1.4 COMPATABI
	DW	224		;DISK SIZE MINUS 1
	DW	95		;DIRECTORY MAX
	DB	192		;ALLOC0
	DB	0		;ALLOC1
	DW	24		;CHECK AREA SIZE
	DW	2		;OFFSET TO START TRACK

	IF	HARDSK
	if	MPM20
DPB3:	DISKDEF	3,0,127,,16384,512,512,0,1,,0

DPB4:	DISKDEF	4,0,127,,16384,512,512,0,513,,0

DPB5:	DISKDEF 5,0,127,,16384,512,512,0,1025,,0

DPB6:	DISKDEF	6,0,127,,16384,288,512,0,513,,0
	else
DPB3:	DISKDEF	3,0,127,,16384,512,512,0,1

DPB4:	DISKDEF	4,0,127,,16384,512,512,0,513

DPB5:	DISKDEF	5,0,127,,16384,512,512,0,1025

DPB6:	DISKDEF	6,0,127,,16384,288,512,0,513
	endif

	ENDIF

	if	MDISK
DPB7	EQU	$		;VIRTUAL DISK
	DW	24		;SECTORS PER TRACK
	DB	3		;BLOCK SHIFT
	DB	7		;BLOCK SHIFT MASK
	DB	0		;EXTENT MASK
	DW	142		;DISK SIZE MINUS 1
	DW	63		;DIRECTORY MAX
	DB	0C0H		;ALLOCO
	DB	0		;ALLOC1
	DW	0		;CHECK AREA SIZE
	DW	0		;OFFSET TO START TRACK
	endif

;
;	MOVE SUBROUTINE
;

	if	HARDSK
RWMOVE:
	push	de
	push	hl
	call	SWTUSER		;switch in user bank
	pop	hl
	pop	de
	ld	bc,128
	LDIR			;MOVE DATA TO/FROM BUFFER
	call	SWTSYS		;switch system back in
;
;	DATA HAS BEEN MOVED TO/FROM HOST BUFFER
;
	LD	A,(WRTYPE)		;WRITE TYPE ??

	if	MPM20
	and	WRDIR		;TO DIRECTORY ??
	JR	Z,RWEND		;NO, JUST END UP HERE
	else
	CP	WRDIR		;TO DIRECTORY ??
	JR	NZ,RWEND		NO, JUST END UP HERE
	endif

;
;	CLEAR HOST BUFFER FOR DIRECTORY WRITE
;

	LD	A,(ERFLAG)		;CHECK PRIOR TO DIR ACTIVIT
	OR	A		;ERRORS ??
	JR	NZ,RWEND		;SKIP IF SO....
	XOR	A		;ZERO TO ACCUMULATOR
	LD	(HSTWRT),A		;BUFFER WRITTEN
	CALL	WRITEHST	;

RWEND:
	LD	A,(ERFLAG)		;
	OR	A		;IF ERRORS, RESET SO NO MAT
	RET	Z		;NONE, JUST RETURN
	LD	HL,HSTDSK	;
	LD	(HL), 0FFH		;CANT POSSIBLY MATCH, MUST
	ENDIF
	RET			;

MVDTB:
	LD	HL,(DMAADR)		; MOVE DATA TO FLOPPY BUFFE
	push	hl
	call	SWTUSER	;switch in user bank,
	pop	hl	;   cannot access non-common BNKXIO
	LD	DE,FPYBUF	;
	LD	BC,128		; 128 BYTES
	LDIR			;
	jp	SWTSYS		;switch system back in
	RET			;

MVDFB:	PUSH	AF		;MOVE DATA FROM FLOPPY BUF
	LD	A,(CMD)		;
	AND	20H		; CHECK FOR READ
	JR	NZ,MVDFX		; NO - BYPAS MOVE
	LD	HL,(DMAADR)		;
	push	hl
	call	SWTUSER	;switch in user bank,
	pop	de	;   cannot access non-common BNKXIO
	LD	HL,FPYBUF	;
	LD	BC,128		; 128 BYTES
	LDIR			;
	call	SWTSYS		;switch system back in
MVDFX:	POP	AF		;
	RET			;

	IF	HARDSK

	DS	1			;MUST PRECEDE HSTBU
HSTBUF:	DS	1024			;HOST BUFFER AREA
	DS	1			;MUST FOLLOW HSTBUF
	ENDIF

	if	MPM20
DIRBUF	equ	$
FPYBUF	equ	DIRBUF+128
	endif

SYSTEMINIT:
	; C  = BREAKPOINT RESTART NUMBER
	; DE = BREAKPOINT RESTART HANDLER ADDRESS
	; HL = DIRECT XIOS INTERCEPT JUMP TABLE ADDRESS

	LD	(SVDJT),HL
	LD	L,C
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL	;HL= RESTART JUMP ADDRESS
	LD	(SVDBPA),HL

	if	~~MDISK
	ld	hl,(SYSDAT)
	ld	l,15	;hl = .nmbmemsegs
	ld	b,(hl)	;b =  nmbmemsegs
TEST_BANK_SETUP_LOOP:
	inc	hl
	inc	hl
	inc	hl
	inc	hl	;hl = .memseg(i). bank
	ld	a,(hl)
	or	a
	jp	nz,BANK_SETUP
	dec	b
	jp	nz,TEST_BANK_SETUP_LOOP
	jp	AFTER_BANK_SETUP
BANK_SETUP:
	LD	A,01AH		; SELECT BANK 3
	CALL	STMVTR		; SET UP VECTORS
	LD	A,012H		; SELECT BANK 2
	CALL	STMVTR		; SET UP VECTORS
	LD	A,00AH		; SELECT BANK 1
	CALL	STMVTR		; SET UP VECTORS
AFTER_BANK_SETUP:
	else
	ld	a,lah		; bank 3 select for directo
	out	(09h),a
	ld	hl,0bffeh
	ld	a,0e5h
	cp	(hl)
	inc	hl
	jr	nz,fill
	cp	(hl)
	jr	z,dontfill
FILL:
	ld	(hl),a		;set directory initialized
	dec	hl
	ld	(hl),a

	ld	bc,07ffh		;first 2 k of bank one gets
	ld	hl,0
	ld	de,1
	ld	a,0ah		; select bank 1
	out	(09h),a
	ld	(hl),0e5h
	ldir
DONTFILL:
	endif
	LD	A,002H		; SELECT BANK 0
	CALL	STMVTR		; SET UP VECTORS

	ld	hl,LDRBIOSBASE+DENSITY_MASK_OFFSET
;;;;;	LD	HL,1737H	; MOVE PARAMETERS CHANGED B
	LD	DE,SEL0		;	THE SETUP PROGRAM
	LD	BC,4		;  4 SELECT MASKS
	LDIR			;
	LD	DE,MODE		;
	LD	BC,4		;  4 MODE BYTES
	LDIR			;
	ld	hl,(LDRBIOSBASE+MISC_PARAMS_OFFSET)
	LD	HL,(17BBH)		; GET MISC. PARAMETERS
	LD	(MPARMS),HL		;
	LD	A,(MPARMS)		; NOW TEST FOR CENTRONICS P
	AND	2		;
	JR	Z,PRTOK		;    NO - LEAVE SERIAL
	LD	HL,CLIST		;
	LD	(WBOTE+13),HL	; CHANGE PRINTER ROUTINE
	LD	HL,CNSTAT	;   AND STATUS CHECK
	LD	(DEVTBL),HL		;
	LD	A,003H		;INITIALIZE PARALLEL PORT
	OUT	(013H),A
	LD	A,00FH		;
	OUT	(013H),A

PRTOK:
	LD	BC,003H		;SET THE MODE FOR DRIVES IN
MODESET:
	CALL	SELSDP		;SELECT DRIVE FOR MODESET
	LD	HL,MODE		;
	ADD	HL,BC		;POINT TO CORRECT MODE BYTE
	PUSH	BC		;SAVE COUNT OF DRIVES
	LD	B,C		; B = DRIVE #
	LD	C,(HL)		;
	CALL	XETMOD		;SET MODE
	POP	BC		;
	DEC	C		;END OF LIST YET ??
	JP	MODESET		;SET MODE FOR ALL DRIVES
	CALL	SDCONF		;SET DISK CONFIGURATION

	LD	BC,80H
	CALL	SETDMA		;SET DMA ADDRESS

	push	hl

	if	MPM20
	ld	hl,(SYSDAT)
	ld	l,7
	ld	a,(hl)
	else
	ld	hl,INTERUPT
	ld	a,h
	endif

	pop	hl
	DB	0EDH,047H	;---- FAKE STAI INSTRUCTION
	LD	A,60H		; SET VECTOR FOR CTC
	OUT	(30H),A		; CTC CHANNEL 0
	LD	A,0A7H		; RESET  /  LOAD TIME CONST
	OUT	(33H),A		; CHANNEL 3
	LD	A,250		; TIME CONSTANT
	OUT	(033H),A		;

	IF	HARDSK
	XOR	A		;ZERO ACCUMULATOR
	LD	(HSTACT),A		;SET HOST BUFFER INACTIVE
	LD	(UNACNT),A		;SET UNALLOCATED COUNT TO Z

	LD	HL,HSTBUF-1	;SETUP WRITE CONTROL BYTE F
	LD	(HL),00DH		;
	ENDIF

	RET			;

STMVTR:
	OUT	(MEMPORT),A
	LD	A,0C3H		; SET VECTORS FOR BDOS
	LD	(0),A		;  JMP INSTRUCTION
	LD	HL,(SVDJT)		;
	LD	(1),HL
	LD	HL,(SVDBPA)
	LD	(HL),A
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	RET			;

SVDJT:	DS	2	; SAVED DIRECT JUMP TABLE ADDRESS
SVDBPA:	DS	2	; SAVED BREAK POINT ADDRESS

	if	MPM20
XIOSEND	equ	$
FDBUF	equ	(DIRBUF-BASE) +256
	org FDBUF+((XIOSEND-BASE)/FDBUF)*((XIOSEND-BASE)-FDBUF)
	db	0
	endif

	END
